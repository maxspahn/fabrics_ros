#!/usr/bin/env python3
import numpy as np
import time
import datetime
import rospy
import rospkg
import os

import tf
from std_msgs.msg import Float64MultiArray, ColorRGBA
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, PoseStamped, Pose, Quaternion, Vector3
from visualization_msgs.msg import Marker, MarkerArray

from fabrics_msgs.msg import FabricGoal, FabricGoalArray, FabricsObstacle, FabricsObstacleArray, FabricsState

from MotionPlanningGoal.goalComposition import GoalComposition
from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from fabrics.planner.serialized_planner import SerializedFabricPlanner
from forwardkinematics.urdfFks.pandaFk import PandaFk

# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z
Point.__iter__ = _it

def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w
Quaternion.__iter__ = _it

class FabricsNode(object):
    def __init__(self):
        rospy.init_node('fabrics_node')
        self.rate = rospy.Rate(500)
        self.num_obstacles = 0 if not rospy.has_param("num_obs") else rospy.get_param("num_obs")
        self.positional_goal_tolerance = 0.05 if not rospy.has_param("positional_goal_tolerance") else rospy.get_param("positional_goal_tolerance")
        self.angular_goal_tolerance = 0.10 if not rospy.has_param("angular_goal_tolerance") else rospy.get_param("angular_goal_tolerance")
        self.serialize_file_name = "None" if not rospy.has_param("serialize_file_name") else rospy.get_param("serialize_file_name")
        # get an instance of RosPack with the default search paths
        rospack = rospkg.RosPack()
        # path of serialize_file should be stored to
        self.serialize_file = rospack.get_path('fabrics_bridge') + "/scripts/" + self.serialize_file_name
        self.planner = self.init_planner()

        self.init_publishers()
        self.init_subscribers()

        self.state = FabricsState()
        self.state.goal_reached = False
        self.state.angular_error = 1

        self.init_markers()

        self.tf_listener = tf.TransformListener()
        self.tf_broadcaster = tf.TransformBroadcaster()
        rospy.sleep(1.0)

    def init_planner(self):
        # TODO: Replace PandaFK by generic FK that reads from robot_description
        # TODO: Add full body control robot type as an option
        robot_type = "panda"
        degrees_of_freedom = 7

        # if the serialize_file exists, deserialize it
        if os.path.isfile(self.serialize_file):
            planner = SerializedFabricPlanner(self.serialize_file)

        else:
            planner = ParameterizedFabricPlanner(degrees_of_freedom, robot_type)
            fk = PandaFk()
            q = planner.variables.position_variable()
            forward_kinematics = [fk.fk(q, i, positionOnly=True) for i in range(1, degrees_of_freedom+1)]

            goal_dict = {
                "position": {
                    "m": 3,
                    "w": 0.6, # attractor weight
                    "prime": True,
                    "indices": [0, 1, 2],
                    "parent_link": "panda_link0",
                    "child_link": "panda_hand",
                    "desired_position": [0.5, 0.0, 0.5],
                    "epsilon": 0.01,
                    "type": "staticSubGoal",
                },
                "orientation": {
                    "m": 2,
                    "w": 20, # attractor weight
                    "prime": False,
                    "indices": [0, 1],
                    "parent_link": "panda_link7",
                    "child_link": "panda_hand",
                    "angle": [0.707, 0.0, 0.0, 0.707],
                    "desired_position": [0.0, 0.0],
                    "epsilon": 0.01,
                    "type": "staticSubGoal",
                },
            }
            self.planning_goal = GoalComposition(name="goal", contentDict=goal_dict)

            # The planner hides all the logic behind the function set_components.
            planner.set_components(
                forward_kinematics,
                self.planning_goal,
                number_obstacles=self.num_obstacles,
            )
            planner.concretize()
            # serializing is optional, so only serialize when there is serialize_file_name set
            if self.serialize_file_name != "None":
                rospy.loginfo("The serialize file doesn't exist. Serializing the planner to %s, it will take a while!", self.serialize_file)
                planner.serialize(self.serialize_file)
                rospy.loginfo("Finished serializing, %s has been created", self.serialize_file)

        return planner

    def init_publishers(self):
        self.goal_marker_publisher = rospy.Publisher(
            'planning_goal/marker',
            Marker, queue_size=10
        )
        self.obs_markers_publisher = rospy.Publisher(
            'planning_obs/markers',
            MarkerArray, queue_size=10
        )
        self.action_message = Float64MultiArray(data=np.zeros(9))
        self.action_publisher = rospy.Publisher(
            '/joint_acc_des', 
            Float64MultiArray, queue_size=10
        )
        self.state_publisher = rospy.Publisher(
            'state', 
            FabricsState, queue_size=10
        )

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            'planning_obs',
            FabricsObstacleArray, self.obs_callback
        )
        self.obstacles = []
        self.goal_subscriber = rospy.Subscriber(
            'planning_goal',
            PoseStamped, self.goal_callback
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            '/joint_states_filtered',
            JointState, 
            self.joint_states_callback,
            # lambda msg: self._joint_states=msg,
            tcp_nodelay=True
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles

    def goal_callback(self, msg: PoseStamped):
        self.goal = msg

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = msg.name[5:]
        self.joint_states.position = msg.position[5:]
        self.joint_states.velocity = msg.velocity[5:]

    def init_markers(self):
        def init_marker(a, r, g, b, type=2):
            goal_marker = Marker()
            goal_marker.header.frame_id = "panda_link0"
            goal_marker.type = type
            goal_marker.action = goal_marker.ADD
            goal_marker.color = ColorRGBA(a=a, r=r, g=g, b=b)
            return goal_marker

        self.goal_marker = init_marker(1, 0, 0, 1, type=0)
        self.goal_marker.points = [Point(x=0, y=0, z=0), Point(x=0, y=0, z=0.35)]
        self.goal_marker.id = 1
        self.goal_marker.scale = Vector3(0.02, 0.04, 0.04)

        self.obs_markers = MarkerArray()
        self.obs_markers.markers = [init_marker(1, 1, 0, 0) for i in range(self.num_obstacles)]
        for i, m in enumerate(self.obs_markers.markers): m.id = i

    def update_markers(self):
        self.goal_marker.color.g = 1.0 if self.state.goal_reached else 0.0
        self.goal_marker.color.b = 0.0 if self.state.goal_reached else 1.0

        self.goal_marker.pose = self.goal.pose
        self.goal_marker_publisher.publish(self.goal_marker)

        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles: break
            self.obs_markers.markers[i].pose.position = o.position 
            self.obs_markers.markers[i].scale = Vector3(o.radius, o.radius, o.radius) 
        self.obs_markers_publisher.publish(self.obs_markers)

    def compute_action(self):
        # Orientation fix
        euler_goal = list(tf.transformations.euler_from_quaternion(list(self.goal.pose.orientation), 'rxyz'))
        rot_mat = tf.transformations.euler_matrix(-euler_goal[1], -euler_goal[0], 0, 'ryxz')[:3, :3]

        # Ensure right number of obstacles, if less are received fill with [100, 100, 100], if more received naively take the first ones.
        x_obst = np.full((self.num_obstacles, 3), [100.0]*3)
        radius_obst = np.full((self.num_obstacles, 1), 0.05)
        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles: break
            x_obst[i, :] = list(o.position)
            radius_obst[i] = o.radius

        return self.planner.compute_action(
            q=list(self.joint_states.position),
            qdot=list(self.joint_states.velocity),
            x_goal_0=list(self.goal.pose.position),
            weight_goal_0=np.array([0.60]),
            radius_body=np.array([0.10]),
            angle_goal_1=rot_mat,
            x_goal_1=[0.0, 0.0],
            weight_goal_1=np.array([30.6]),
            x_obst = x_obst,
            radius_obst = radius_obst,
            weight_obst = np.array([0.0001])
        )

    def act(self):
        if not len(self.joint_states.name) > 0: return
        self.action_message.data = [0, 0] + list(self.compute_action())
        self.action_publisher.publish(self.action_message)

    def evaluate(self):
        # broadcast goal frame
        # Note: at 10x lower frequency than act loop, because tf
        if not hasattr(self, "eval_i"): self.eval_i = 0
        self.eval_i+=1
        if self.eval_i%10 == 0:
            self.eval_i = 0
            self.tf_broadcaster.sendTransform(
                list(self.goal.pose.position),
                list(self.goal.pose.orientation),
                rospy.Time.now(),
                "/fabrics_goal",
                "/panda_link0")

        # evaluate positional_error
        (trans, rot) = self.tf_listener.lookupTransform('/panda_link0', '/panda_link8', rospy.Time(0))
        self.state.positional_error = np.linalg.norm(np.array(trans) - list(self.goal.pose.position))

        # evaluate angular_error
        # Note: this is done by taking the L2 norm between a point at z=0.5 along the '/panda_link8' frame and transforming it to the goal frame
        p1 = PoseStamped()
        p1.header.frame_id = '/panda_link8'
        p1.pose.position = Point(x=0, y=0, z=0.5)
        try:
            p2 = self.tf_listener.transformPose('/fabrics_goal', p1)
            self.state.angular_error = np.linalg.norm(np.array(list(p1.pose.position))-list(p2.pose.position))
            print(self.state.angular_error)
        except Exception as e:
            rospy.logerr(e)

        # update state
        self.state.goal_reached = self.state.positional_error < self.positional_goal_tolerance and self.state.angular_error < self.angular_goal_tolerance
        self.state.header.stamp = rospy.Time.now()
        self.state_publisher.publish(self.state)

    def run(self):
        while not rospy.is_shutdown():
            if hasattr(self, 'goal'):
                self.act()
                self.evaluate()
                self.update_markers()
            else:
                self.state_publisher.publish(self.state)

            self.rate.sleep()

if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
