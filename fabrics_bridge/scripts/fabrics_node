#!/usr/bin/env python3
import numpy as np
import time
import datetime
import rospy
import rospkg
import os

import tf
from std_msgs.msg import Float64MultiArray, ColorRGBA, Bool
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, PoseStamped, Pose, Quaternion, Vector3
from visualization_msgs.msg import Marker, MarkerArray
from urdf_parser_py.urdf import URDF
from fabrics_msgs.msg import FabricsGoal, FabricsGoalArray, FabricsObstacle, FabricsObstacleArray, FabricsState

from MotionPlanningGoal.goalComposition import GoalComposition
from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from fabrics.planner.serialized_planner import SerializedFabricPlanner
from forwardkinematics.urdfFks.pandaFk import PandaFk

# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z
Point.__iter__ = _it

def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w
Quaternion.__iter__ = _it

class FabricsNode(object):
    def __init__(self):
        rospy.init_node('fabrics_node')
        self._goal_type = ""
        self.rate = rospy.Rate(500)
        # retrieve the robot model on the parameter server and parse it to create a URDF robot structure, not the same as robot_description
        self.robot = URDF.from_parameter_server("/robot_description")
        # robot_description should be global because it's not part of fabrics ns
        self.urdf = rospy.get_param("/robot_description")
        # TODO get the joints list from ListControllers srv
        self.list_joints =  ["panda_joint1", "panda_joint2", "panda_joint3", "panda_joint4", "panda_joint5", "panda_joint6", "panda_joint7"]
        self.num_obstacles = 10 if not rospy.has_param("num_obs") else rospy.get_param("num_obs")
        self.positional_goal_tolerance = 0.05 if not rospy.has_param("positional_goal_tolerance") else rospy.get_param("positional_goal_tolerance")
        self.angular_goal_tolerance = 0.10 if not rospy.has_param("angular_goal_tolerance") else rospy.get_param("angular_goal_tolerance")
        self.init_planner('joint_space')
        self.init_planner('ee_pose')
	    # stop motion bool
        self.stop_acc_bool = False

        self.init_publishers()
        self.init_subscribers()

        self.state = FabricsState()
        self.state.goal_reached = False
        self.state.angular_error = 1

        self.publish_self_collision = True
        self.init_markers()

        self.tf_listener = tf.TransformListener()
        self.tf_broadcaster = tf.TransformBroadcaster()
        rospy.sleep(1.0)

    def load_planner(self):
        self.stop_acc_bool = True
        rospack = rospkg.RosPack()
        serialize_file = rospack.get_path('fabrics_bridge') + "/planner/" + f"fabric_planner_{self._goal_type}_obstacles_{self.num_obstacles}"
        self._planner = SerializedFabricPlanner(serialize_file)
        self.stop_acc_bool = False

    def init_planner(self, goal_type: str):
        # TODO: Add full body control robot type as an option
        robot_type = "panda"
        degrees_of_freedom = 7

        planner = ParameterizedFabricPlanner(
            degrees_of_freedom,
            robot_type,
            urdf=self.urdf,
            root_link='panda_link0',
            end_link=["panda_vacuum_2", "panda_vacuum"],
            )
            
        self.planning_goal = self.goal_compose(goal_type)
        rospack = rospkg.RosPack()
        serialize_file = rospack.get_path('fabrics_bridge') + "/planner/" + f"fabric_planner_{goal_type}_obstacles_{self.num_obstacles}"
        if os.path.exists(serialize_file):
            rospy.loginfo(f"Planner is already serialized in {serialize_file}")
            return
            # get the joint limits for each joint
        joint_limits = []
        for i in self.list_joints:
            joint_limits.append([self.robot.joint_map[i].limit.lower, self.robot.joint_map[i].limit.upper])
        collision_links = ["panda_link4", "panda_link6", "panda_vacuum", "panda_vacuum_2"]
        self_collision_pairs = {
	    "panda_hand": ["panda_link2"],
	    "panda_vacuum": ["panda_link1", "panda_link2", "panda_link3"]
	}
        # The planner hides all the logic behind the function set_components.
        planner.set_components(
            collision_links,
            self_collision_pairs,
            self.planning_goal,
            limits=joint_limits,
            number_obstacles=self.num_obstacles,
        )
        planner.concretize()
        # serializing the planner
        rospy.loginfo(f"Serializing the planner for goal_type:  {goal_type}")
        planner.serialize(serialize_file)
        rospy.loginfo(f"Finished serializing, {serialize_file} has been created")


    def goal_compose(self, goal_type: str):
        joint_space_goal_dict = {
            "joint_position": {
                "m": 7,
                "w": 0.2, # attractor weight
                "prime": True,
                "indices": list(range(7)),
                "desired_position": [0.0, 0.0, 0.0, -1.501, 0.0, 0.8675, 0.0],
                "epsilon": 0.01,
                "type": "staticJointSpaceSubGoal",
            }
        }
        ee_pose_goal_dict = {
            "position": {
                "m": 3,
                "w": 0.15, # attractor weight
                "prime": True,
                "indices": [0, 1, 2],
                "parent_link": "panda_link0",
                "child_link": "panda_vacuum",
                "desired_position": [0.5, 0.0, 0.5],
                "epsilon": 0.01,
                "type": "staticSubGoal",
            },
            "orientation": {
                "m": 2,
                "w": 0.3, # attractor weight
                "prime": False,
                "indices": [0, 1],
                "parent_link": "panda_hand",
                "child_link": "panda_vacuum",
                "angle": [0.707, 0.0, 0.0, 0.707],
                "desired_position": [0.0, 0.0],
                "epsilon": 0.01,
                "type": "staticSubGoal",
            },
        }
        if goal_type == 'ee_pose':
            goal_dict = ee_pose_goal_dict
        elif goal_type == 'joint_space':
            goal_dict = joint_space_goal_dict
        planning_goal = GoalComposition(name="goal", contentDict=goal_dict)
        return planning_goal

    def init_publishers(self):
        self.goal_marker_publisher = rospy.Publisher(
            'planning_goal/marker',
            Marker, queue_size=10
        )
        self.obs_markers_publisher = rospy.Publisher(
            'planning_obs/markers',
            MarkerArray, queue_size=10
        )
        self.action_message = Float64MultiArray(data=np.zeros(9))
        self.action_publisher = rospy.Publisher(
            '/joint_acc_des', 
            Float64MultiArray, queue_size=10
        )
        self.state_publisher = rospy.Publisher(
            'state', 
            FabricsState, queue_size=10
        )

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            'planning_obs',
            FabricsObstacleArray, self.obs_callback
        )
        self.obstacles = []
        self.goal_subscriber = rospy.Subscriber(
            'planning_goal',
            FabricsGoal, self.goal_callback
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            '/joint_states_filtered',
            JointState, 
            self.joint_states_callback,
            # lambda msg: self._joint_states=msg,
            tcp_nodelay=True
        )
        # stop publishing joint_acc_des once the cb is triggered
        self.acc_stop_subscriber = rospy.Subscriber(
            "acc_stop_request",
            Bool, self.acc_stop_callback
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles

    def goal_callback(self, msg: FabricsGoal):
        if not self._goal_type == msg.goal_type:
            self._goal_type = msg.goal_type
            self.load_planner()
        if self._goal_type == "ee_pose":
            self.goal = msg.goal_pose
        elif self._goal_type == "joint_space":
            self.goal = msg.goal_joint_state
        else:
            rospy.loginfo("Please specify a goal type, either ee_pose or joint_space")
            return
        self.goal_weight_goal_0 = msg.weight_goal_0
        self.goal_weight_goal_1 = msg.weight_goal_1

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = msg.name[5:]
        self.joint_states.position = msg.position[5:]
        self.joint_states.velocity = msg.velocity[5:]

    def acc_stop_callback(self, msg: Bool):
        self.stop_acc_bool = msg.data

    def init_markers(self):
        def init_marker(a, r, g, b, type=2):
            goal_marker = Marker()
            goal_marker.header.frame_id = "panda_link0"
            goal_marker.type = type
            goal_marker.action = goal_marker.ADD
            goal_marker.color = ColorRGBA(a=a, r=r, g=g, b=b)
            return goal_marker

        self.goal_marker = init_marker(1, 0, 0, 1, type=0)
        self.goal_marker.points = [Point(x=0, y=0, z=0), Point(x=0, y=0, z=0.35)]
        self.goal_marker.id = 1
        self.goal_marker.scale = Vector3(0.02, 0.04, 0.04)

        self.obs_markers = MarkerArray()
        self.obs_markers.markers = [init_marker(1, 1, 0, 0) for i in range(self.num_obstacles)]
        for i, m in enumerate(self.obs_markers.markers): m.id = i

        if self.publish_self_collision:
            # TODO: Individual Markers of a MarkerArray aren't fixed in their respective header frame_id's in rviz as the frames move.
            #       This means the markers don't move with the robot arm as it moves.

            # Latch publish self collision markers
            for joint, collision_pairs  in self.self_collision_pairs.items():
                p = rospy.Publisher(
                    'self_collision/{}'.format(joint),
                    MarkerArray, queue_size=10, latch=True
                )
                m_array = MarkerArray()
                for i, c in enumerate(collision_pairs):
                    print(c)
                    m = init_marker(1, 1, 0, 0)
                    m.header.frame_id = c
                    m.scale = Vector3(0.1, 0.1, 0.1)
                    m.id = i
                    m_array.markers.append(m)
                p.publish(m_array)

    def update_markers(self):
        if isinstance(self.goal, PoseStamped):
            self.goal_marker.color.g = 1.0 if self.state.goal_reached else 0.0
            self.goal_marker.color.b = 0.0 if self.state.goal_reached else 1.0

            self.goal_marker.pose = self.goal.pose
            self.goal_marker_publisher.publish(self.goal_marker)

            for i, o in enumerate(self.obstacles):
                if i >= self.num_obstacles: break
                self.obs_markers.markers[i].pose.orientation = Quaternion(x=0, y=0, z=0, w=1)
                self.obs_markers.markers[i].pose.position = o.position 
                self.obs_markers.markers[i].scale = Vector3(o.radius*2, o.radius*2, o.radius*2)
            self.obs_markers_publisher.publish(self.obs_markers)

    def parse_ee_pose_goal(self):
        # Orientation fix
        euler_goal = list(tf.transformations.euler_from_quaternion(list(self.goal.pose.orientation), 'rxyz'))
        rot_mat = tf.transformations.euler_matrix(-euler_goal[1], -euler_goal[0], 0, 'ryxz')[:3, :3]
        goal_args = {
            'x_goal_0': list(self.goal.pose.position),
            'x_goal_1': np.array([0.0, 0.0]),
            'angle_goal_1':rot_mat,
            'weight_goal_1': np.array(self.goal_weight_goal_1),
            'weight_goal_0': np.array(self.goal_weight_goal_0),
        }
        return goal_args

    def parse_joint_space_goal(self):
        return {
            'x_goal_0': np.array(self.goal.position),
            'weight_goal_0': np.array(self.goal_weight_goal_0),
        }

    def compute_action(self):
        # Ensure right number of obstacles, if less are received fill with [100, 100, 100], if more received naively take the first ones.
        x_obst = np.full((self.num_obstacles, 3), [100.0]*3)
        radius_obst = np.full((self.num_obstacles, 1), 0.05)
        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles: break
            x_obst[i, :] = list(o.position)
            radius_obst[i] = o.radius
        if isinstance(self.goal, PoseStamped):
            goal_args = self.parse_ee_pose_goal()
        elif isinstance(self.goal, JointState):
            goal_args = self.parse_joint_space_goal()
        return self._planner.compute_action(
            q=list(self.joint_states.position),
            qdot=list(self.joint_states.velocity),
            radius_body_panda_link3=np.array([0.1]),
            radius_body_panda_link4=np.array([0.1]),
            radius_body_panda_link5=np.array([0.1]),
            radius_body_panda_link6=np.array([0.1]),
            radius_body_panda_link7=np.array([0.1]),
            radius_body_panda_link8=np.array([0.1]),
            radius_body_panda_vacuum=np.array([0.03]),
            radius_body_panda_vacuum_2=np.array([0.03]),
            x_obst = x_obst,
            radius_obst = radius_obst,
            **goal_args
        )

    def act(self):
        if not len(self.joint_states.name) > 0 or self.stop_acc_bool: return
        self.action_message.data = [0, 0] + list(self.compute_action())
        self.action_publisher.publish(self.action_message)

    def evaluate(self):
        if isinstance(self.goal, JointState):
            self.state.positional_error = np.linalg.norm(
                np.array(self.joint_states.position) - np.array(self.goal.position)
            )
            self.state.angular_error = 0.0
            self.state.goal_reached = self.state.positional_error < self.positional_goal_tolerance
        elif isinstance(self.goal, PoseStamped):
            # broadcast goal frame
            # Note: at 10x lower frequency than act loop, because tf
            if not hasattr(self, "eval_i"): self.eval_i = 0
            self.eval_i+=1
            if self.eval_i%10 == 0:
                self.eval_i = 0
                self.tf_broadcaster.sendTransform(
                    list(self.goal.pose.position),
                    list(self.goal.pose.orientation),
                    rospy.Time.now(),
                    "/fabrics_goal",
                    "/panda_link0")

            # evaluate positional_error
            (trans, rot) = self.tf_listener.lookupTransform('/panda_link0', '/panda_vacuum', rospy.Time(0))
            self.state.positional_error = np.linalg.norm(np.array(trans) - list(self.goal.pose.position))

            # evaluate angular_error
            # Note: this is done by taking the L2 norm between a point at z=0.5 along the '/panda_link8' frame and transforming it to the goal frame
            p1 = PoseStamped()
            p1.header.frame_id = '/panda_vacuum'
            p1.pose.position = Point(x=0, y=0, z=0.5)
            try:
                p2 = self.tf_listener.transformPose('/fabrics_goal', p1)
                self.state.angular_error = np.linalg.norm(np.array(list(p1.pose.position))-list(p2.pose.position))
            except Exception as e:
                rospy.loginfo("Waiting for tf to be on time.")

            # update state
            self.state.goal_reached = self.state.positional_error < self.positional_goal_tolerance and self.state.angular_error < self.angular_goal_tolerance
        self.state.header.stamp = rospy.Time.now()
        self.state_publisher.publish(self.state)

    def run(self):
        while not rospy.is_shutdown():
            if hasattr(self, 'goal'):
                self.act()
                self.evaluate()
                self.update_markers()
            else:
                self.state_publisher.publish(self.state)

            self.rate.sleep()

if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
