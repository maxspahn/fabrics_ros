#!/usr/bin/env python3
import numpy as np
import rospy
import rospkg
import os
import hashlib

from std_msgs.msg import Float64MultiArray, Empty
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, Quaternion
from urdf_parser_py.urdf import URDF
from fabrics_msgs.msg import (
    FabricsState,
    FabricsGoal,
    FabricsObstacleArray,
)

from fabrics.planner.serialized_planner import SerializedFabricPlanner
from fabrics.helpers.casadiFunctionWrapper import InputMissmatchError

from fabrics_marker_manager import FabricsMarkerManager
from fabrics_goal_evaluator import FabricsGoalEvaluator
from fabrics_bridge.planner_creation import create_planner
from fabrics_goal_wrapper import FabricsGoalWrapper

# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


def list_to_unique_hash(a: list) -> str:
    string = ""
    for value in sorted(a):
        string = string.join(value)
    encoded_string = string.encode("utf-8")
    return hashlib.md5(encoded_string).hexdigest()


Quaternion.__iter__ = _it


class FabricsNode(object):
    def __init__(self):
        rospy.init_node("fabrics_node")
        self._goal_type = ""
        self._runtime_arguments = {}
        self.changed_planner = True
        self.stop_acc_bool = True
        self.planners = {}
        self.goal_wrapper = FabricsGoalWrapper()
        self.rate = rospy.Rate(50)
        self.load_parameters()
        self._planner_type = rospy.get_param('/fabrics_planner_type')
        # TODO get the joints list from ListControllers srv
        self.list_joints = [
            "panda_joint1",
            "panda_joint2",
            "panda_joint3",
            "panda_joint4",
            "panda_joint5",
            "panda_joint6",
            "panda_joint7",
        ]
        self.init_publishers()
        self.init_subscribers()
        self.state_evaluator = FabricsGoalEvaluator()
        self.marker_manager = FabricsMarkerManager(self.num_obstacles, self.collision_bodies, self.collision_links, self.self_collision_pairs)
        self.compose_runtime_obstacles_argument()
        self.compose_runtime_parameter_argument()
        self.init_planner("joint_space")
        self.init_planner("ee_pose")
        self.stop_acc_bool = False


    def load_parameters(self):
        self.num_obstacles = rospy.get_param("/num_obs")
        # robot_description should be global because it's not part of fabrics ns
        self.urdf = rospy.get_param("/robot_description")
        self.collision_links = rospy.get_param("/collision_links")
        self.self_collision_pairs = rospy.get_param("/self_collision_pairs")
        self.collision_bodies = rospy.get_param("/collision_bodies")
        # TODO: Currently, fabrics require inputs to be np.arrays. This should be chaged to also allow floats.
        for name, radius in self.collision_bodies.items():
            self._runtime_arguments[name] = np.array([radius])

    def load_planner(self, goal_type):
        self.stop_acc_bool = True
        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        # If the planner is not serialized yet, this node has to wait for the serialization to finish.
        try:
            rospy.loginfo(f"Loading planner for goal type : {goal_type}")
            self._planner = self.planners[serialize_file]
            self.stop_acc_bool = False
        except Exception as e:
            #rospy.logwarn(e)
            rospy.loginfo("Planner not found: Waiting...")
            self._goal_type = ""
            self.stop_acc_bool = True

    def hash_planner_configuration(self, goal_type: str):
        hash_obstacle = hashlib.md5(str(self.num_obstacles).encode("utf-8")).hexdigest()
        hash_self_collision_pairs = list_to_unique_hash(self.self_collision_pairs)
        hash_collision_links = list_to_unique_hash(self.collision_links)
        hash_goal_type = hashlib.md5(goal_type.encode("utf-8")).hexdigest()
        hash_planner_type = self._planner_type
        return (
            hash_obstacle
            + hash_self_collision_pairs
            + hash_collision_links
            + hash_goal_type
            + hash_planner_type
        )

    def init_planner(self, goal_type: str):
        # TODO: Add full body control robot type as an option

        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        if os.path.exists(serialize_file):
            rospy.loginfo(f"Planner is already serialized in {serialize_file}")
            self.planners[serialize_file] = SerializedFabricPlanner(serialize_file)
            return
        planner = create_planner(self.urdf, self._planner_type)
        # get the joint limits for each joint
        self.robot = URDF.from_parameter_server("/robot_description")
        joint_limits = []
        for i in self.list_joints:
            joint_limits.append(
                [
                    self.robot.joint_map[i].limit.lower,
                    self.robot.joint_map[i].limit.upper,
                ]
            )
        # The planner hides all the logic behind the function set_components.
        dummy_goal = self.goal_wrapper.compose_dummy_goal(goal_type)
        planner.set_components(
            self.collision_links,
            self.self_collision_pairs,
            dummy_goal,
            limits=joint_limits,
            number_obstacles=self.num_obstacles,
        )
        # serializing the planner
        rospy.loginfo(f"Creating the planner for goal_type: {goal_type}")
        planner.concretize()
        planner.serialize(serialize_file)
        rospy.loginfo(f"Finished serializing, {serialize_file} has been created")
        self.planners[serialize_file] = planner


    def run(self):
        while not rospy.is_shutdown():
            # act and evaluate only when a goal, joint_states and a correct planner are received
            if (
                hasattr(self, '_goal')
                and not self.stop_acc_bool
            ):
                self.act()
                goal_is_reached = self.state_evaluator.evaluate(
                    self._goal_msg, self.joint_states
                )
                self.marker_manager.update_markers(
                    self._goal_msg, self.obstacles, goal_is_reached
                )
            self.rate.sleep()

    def init_publishers(self):
        self.action_message = Float64MultiArray(data=np.zeros(9))
        self.action_publisher = rospy.Publisher(
            "/joint_acc_des", Float64MultiArray, queue_size=10
        )

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            "planning_obs", FabricsObstacleArray, self.obs_callback,
            tcp_nodelay=True,
        )
        self.obstacles = []
        self.goal_subscriber = rospy.Subscriber(
            "planning_goal", FabricsGoal, self.goal_callback,
            tcp_nodelay=True,
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            "/joint_states_filtered",
            JointState,
            self.joint_states_callback,
            tcp_nodelay=True,
        )
        # preempt the previous goal once this cb is triggered
        self.preempt_goal_subscriber = rospy.Subscriber(
            "preempt_goal", Empty, self.preempt_goal_callback
        )
        self.set_parameters_subscriber = rospy.Subscriber(
            "set_parameters", Empty, self.parameter_setting_callback
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles
        self.compose_runtime_obstacles_argument()

    def goal_callback(self, msg: FabricsGoal):
        self._goal_msg = msg
        self._goal, changed_planner = self.goal_wrapper.wrap(msg)

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = msg.name[5:]
        self.joint_states.position = msg.position[5:]
        self.joint_states.velocity = msg.velocity[5:]

    def preempt_goal_callback(self, msg: Empty):
        rospy.loginfo(f"goal preempted")
        # only change the weights
        self._goal_msg.weight_goal_0=0
        self._goal_msg.weight_goal_1=0
        self._goal, changed_planner = self.goal_wrapper.wrap(self._goal_msg)

    def parameter_setting_callback(self, data):
        rospy.loginfo("Setting parameters from parameter server")
        self.compose_runtime_parameter_argument()

    def compose_runtime_obstacles_argument(self):
        x_obst = np.full((self.num_obstacles, 3), [100.0] * 3)
        radius_obst = np.full((self.num_obstacles, 1), 0.05)
        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles:
                rospy.logwarn(
                    f"Fabrics planner received more obstacles that it can process by the client: received {len(self.obstacles)} but can only handle {self.num_obstacles}.Consider increasing the rosparameter num_obstacles."
                )
                break
            x_obst[i, :] = list(o.position)
            radius_obst[i] = o.radius
        obstacle_runtime_arguments = self.collision_bodies
        self._runtime_arguments.update({'x_obst': x_obst, 'radius_obst': radius_obst})

    def compose_runtime_parameter_argument(self):
        k_col_geo = np.array([rospy.get_param('/fabrics_geometries/collision_avoidance/geo/k')])
        exp_col_geo = np.array([rospy.get_param('/fabrics_geometries/collision_avoidance/geo/exp')])
        k_limit_geo = np.array([rospy.get_param('/fabrics_geometries/limit/geo/k')])
        exp_limit_geo = np.array([rospy.get_param('/fabrics_geometries/limit/geo/exp')])
        k_self_geo = np.array([rospy.get_param('/fabrics_geometries/self_collision_avoidance/geo/k')])
        exp_self_geo = np.array([rospy.get_param('/fabrics_geometries/self_collision_avoidance/geo/exp')])
        k_col_fin = np.array([rospy.get_param('/fabrics_geometries/collision_avoidance/fin/k')])
        exp_col_fin = np.array([rospy.get_param('/fabrics_geometries/collision_avoidance/fin/exp')])
        k_limit_fin = np.array([rospy.get_param('/fabrics_geometries/limit/fin/k')])
        exp_limit_fin = np.array([rospy.get_param('/fabrics_geometries/limit/fin/exp')])
        k_self_fin = np.array([rospy.get_param('/fabrics_geometries/self_collision_avoidance/fin/k')])
        exp_self_fin = np.array([rospy.get_param('/fabrics_geometries/self_collision_avoidance/fin/exp')])
        base_inertia = np.array([rospy.get_param('/fabrics_geometries/base_inertia')])
        alpha_b_damper = np.array([rospy.get_param('/fabrics_geometries/damper/alpha_b')])
        radius_shift_damper = np.array([rospy.get_param('/fabrics_geometries/damper/radius_shift')])
        beta_distant_damper = np.array([rospy.get_param('/fabrics_geometries/damper/beta_distant')])
        beta_close_damper = np.array([rospy.get_param('/fabrics_geometries/damper/beta_close')])
        self._runtime_arguments[f'base_inertia'] = base_inertia
        self._runtime_arguments[f'alpha_b_damper'] = alpha_b_damper
        self._runtime_arguments[f'radius_shift_damper'] = radius_shift_damper
        self._runtime_arguments[f'beta_close_damper'] = beta_close_damper
        self._runtime_arguments[f'beta_distant_damper'] = beta_distant_damper
        for i in range(self.num_obstacles):
            for link in self.collision_links:
                self._runtime_arguments[f'exp_fin_obst_{i}_{link}_leaf'] = exp_col_fin
                self._runtime_arguments[f'k_fin_obst_{i}_{link}_leaf'] = k_col_fin
                self._runtime_arguments[f'exp_geo_obst_{i}_{link}_leaf'] = exp_col_geo
                self._runtime_arguments[f'k_geo_obst_{i}_{link}_leaf'] = k_col_geo
        for i in range(7):
            for j in range(2):
                self._runtime_arguments[f'exp_limit_fin_limit_joint_{i}_{j}_leaf'] = exp_limit_fin
                self._runtime_arguments[f'k_limit_fin_limit_joint_{i}_{j}_leaf'] = k_limit_fin
                self._runtime_arguments[f'exp_limit_geo_limit_joint_{i}_{j}_leaf'] = exp_limit_geo
                self._runtime_arguments[f'k_limit_geo_limit_joint_{i}_{j}_leaf'] = k_limit_geo
        for link, paired_links in self.self_collision_pairs.items():
            for paired_link in paired_links:
                self._runtime_arguments[f'exp_self_fin_self_collision_{link}_{paired_link}'] = exp_self_fin
                self._runtime_arguments[f'k_self_fin_self_collision_{link}_{paired_link}'] = k_self_fin
                self._runtime_arguments[f'exp_self_geo_self_collision_{link}_{paired_link}'] = exp_self_geo
                self._runtime_arguments[f'k_self_geo_self_collision_{link}_{paired_link}'] = k_self_geo




    def compute_action(self):
        goal_runtime_arguments = self.goal_wrapper.compose_runtime_arguments(self._goal)
        # Ensure right number of obstacles, if less are received fill with [100, 100, 100], if more received naively take the first ones.
        self._runtime_arguments['q'] = list(self.joint_states.position)
        self._runtime_arguments['qdot'] = list(self.joint_states.velocity)
        self._runtime_arguments.update(goal_runtime_arguments)
        return self._planner.compute_action(
            **self._runtime_arguments,
        )

    def act(self):
        try:
            self.action_message.data = [0, 0] + list(self.compute_action())
            self.action_publisher.publish(self.action_message)
        except InputMissmatchError as input_error_fabrics:
            rospy.loginfo(f"Not planning due to error {str(input_error_fabrics)[:80]}.")
            rospy.loginfo("Waiting for correct planner to be loaded.")
            self.load_planner(self.goal_wrapper._goal_type)
        except Exception as e:
            rospy.loginfo(f"Not planning due to error {e}.")
            rospy.loginfo("Waiting for correct planner to be loaded.")
            self.load_planner(self.goal_wrapper._goal_type)


if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
