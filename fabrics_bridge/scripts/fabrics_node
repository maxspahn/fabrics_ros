#!/usr/bin/env python3
import numpy as np
import rospy
import rospkg
import os
import hashlib

from std_msgs.msg import Float64MultiArray, Bool
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, PoseStamped, Quaternion
from urdf_parser_py.urdf import URDF
from fabrics_msgs.msg import (
    FabricsState,
    FabricsGoal,
    FabricsObstacleArray,
)

from MotionPlanningGoal.goalComposition import GoalComposition
from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from fabrics.planner.serialized_planner import SerializedFabricPlanner

from fabrics_marker_manager import FabricsMarkerManager
from fabrics_goal_evaluator import FabricsGoalEvaluator
from fabrics_goal_wrapper import FabricsGoalWrapper
from visualization_msgs.msg import Marker, MarkerArray


# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


def list_to_unique_hash(a: list) -> str:
    string = ""
    for value in sorted(a):
        string = string.join(value)
    encoded_string = string.encode("utf-8")
    return hashlib.md5(encoded_string).hexdigest()


Quaternion.__iter__ = _it


class FabricsNode(object):
    def __init__(self):
        rospy.init_node("fabrics_node")
        self._goal_type = ""
        self.changed_planner = True
        self.stop_acc_bool = True
        self.planners = {}
        self.goal_wrapper = FabricsGoalWrapper()
        self.rate = rospy.Rate(500)
        self.load_parameters()
        # TODO get the joints list from ListControllers srv
        self.list_joints = [
            "panda_joint1",
            "panda_joint2",
            "panda_joint3",
            "panda_joint4",
            "panda_joint5",
            "panda_joint6",
            "panda_joint7",
        ]
        self.init_publishers()
        self.init_subscribers()
        self.state_evaluator = FabricsGoalEvaluator()
        self.marker_manager = FabricsMarkerManager(self.num_obstacles, self.collision_bodies, self.collision_links, self.self_collision_pairs)

        self.init_planner("joint_space")
        self.init_planner("ee_pose")
        self.stop_acc_bool = False
        self._obstacle_runtime_arguments = self.compose_runtime_obstacles_argument()


    def load_parameters(self):
        self.num_obstacles = rospy.get_param("/num_obs")
        # robot_description should be global because it's not part of fabrics ns
        self.urdf = rospy.get_param("/robot_description")
        self.collision_links = rospy.get_param("/collision_links")
        self.self_collision_pairs = rospy.get_param("/self_collision_pairs")
        self.collision_bodies = rospy.get_param("/collision_bodies")
        # TODO: Currently, fabrics require inputs to be np.arrays. This should be chaged to also allow floats.
        for name, radius in self.collision_bodies.items():
            self.collision_bodies[name] = np.array([radius])

    def load_planner(self, goal_type):
        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        # If the planner is not serialized yet, this node has to wait for the serialization to finish.
        try:
            rospy.loginfo(f"Loading planner for goal type : {goal_type}")
            self._planner = self.planners[serialize_file]
        except Exception as e:
            rospy.logwarn(e)
            rospy.loginfo("Planner not found: Waiting...")
            self._goal_type = ""

    def hash_planner_configuration(self, goal_type: str):
        hash_obstacle = hashlib.md5(str(self.num_obstacles).encode("utf-8")).hexdigest()
        hash_self_collision_pairs = list_to_unique_hash(self.self_collision_pairs)
        hash_collision_links = list_to_unique_hash(self.collision_links)
        hash_goal_type = hashlib.md5(goal_type.encode("utf-8")).hexdigest()
        return (
            hash_obstacle
            + hash_self_collision_pairs
            + hash_collision_links
            + hash_goal_type
        )

    def init_planner(self, goal_type: str):
        # TODO: Add full body control robot type as an option

        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        if os.path.exists(serialize_file):
            rospy.loginfo(f"Planner is already serialized in {serialize_file}")
            self.planners[serialize_file] = SerializedFabricPlanner(serialize_file)
            return
        robot_type = "panda"
        degrees_of_freedom = 7

        planner = ParameterizedFabricPlanner(
            degrees_of_freedom,
            robot_type,
            urdf=self.urdf,
            root_link="panda_link0",
            end_link=["panda_vacuum_2", "panda_vacuum"],
        )
        # get the joint limits for each joint
        self.robot = URDF.from_parameter_server("/robot_description")
        joint_limits = []
        for i in self.list_joints:
            joint_limits.append(
                [
                    self.robot.joint_map[i].limit.lower,
                    self.robot.joint_map[i].limit.upper,
                ]
            )
        # The planner hides all the logic behind the function set_components.
        dummy_goal = self.goal_wrapper.compose_dummy_goal(goal_type)
        planner.set_components(
            self.collision_links,
            self.self_collision_pairs,
            dummy_goal,
            limits=joint_limits,
            number_obstacles=self.num_obstacles,
        )
        planner.concretize()
        # serializing the planner
        rospy.loginfo(f"Serializing the planner for goal_type:  {goal_type}")
        planner.serialize(serialize_file)
        rospy.loginfo(f"Finished serializing, {serialize_file} has been created")
        self.planners[serialize_file] = planner


    def run(self):
        while not rospy.is_shutdown():
            # act and evaluate only when a goal, joint_states and a correct planner are received
            if (
                hasattr(self, '_goal')
                and len(self.joint_states.name) > 0
                and not self.stop_acc_bool
            ):
                self.act()
                goal_is_reached = self.state_evaluator.evaluate(
                    self._goal_msg, self.joint_states
                )
                self.marker_manager.update_markers(
                    self._goal_msg, self.obstacles, goal_is_reached
                )
            self.rate.sleep()

    def init_publishers(self):
        self.action_message = Float64MultiArray(data=np.zeros(9))
        self.action_publisher = rospy.Publisher(
            "/joint_acc_des", Float64MultiArray, queue_size=10
        )

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            "planning_obs", FabricsObstacleArray, self.obs_callback
        )
        self.obstacles = []
        self.goal_subscriber = rospy.Subscriber(
            "planning_goal", FabricsGoal, self.goal_callback
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            "/joint_states_filtered",
            JointState,
            self.joint_states_callback,
            tcp_nodelay=True,
        )
        # stop publishing joint_acc_des once the cb is triggered
        self.acc_stop_subscriber = rospy.Subscriber(
            "acc_stop_request", Bool, self.acc_stop_callback
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles
        self._obstacle_runtime_arguments = self.compose_runtime_obstacles_argument()

    def goal_callback(self, msg: FabricsGoal):
        if not self._goal_msg == msg:
            self.stop_acc_bool = False
        self._goal_msg = msg
        self._goal, changed_planner = self.goal_wrapper.wrap(msg)

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = msg.name[5:]
        self.joint_states.position = msg.position[5:]
        self.joint_states.velocity = msg.velocity[5:]

    def acc_stop_callback(self, msg: Bool):
        self.stop_acc_bool = msg.data

    def compose_runtime_obstacles_argument(self):
        x_obst = np.full((self.num_obstacles, 3), [100.0] * 3)
        radius_obst = np.full((self.num_obstacles, 1), 0.05)
        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles:
                rospy.logwarn(
                    f"Fabrics planner received more obstacles that it can process by the client: received {len(self.obstacles)} but can only handle {self.num_obstacles}.Consider increasing the rosparameter num_obstacles."
                )
                break
            x_obst[i, :] = list(o.position)
            radius_obst[i] = o.radius
        obstacle_runtime_arguments = self.collision_bodies
        obstacle_runtime_arguments.update({'x_obst': x_obst, 'radius_obst': radius_obst})
        return obstacle_runtime_arguments


    def compute_action(self):
        goal_runtime_arguments = self.goal_wrapper.compose_runtime_arguments(self._goal)
        # Ensure right number of obstacles, if less are received fill with [100, 100, 100], if more received naively take the first ones.
        runtime_arguments = {}
        state_runtime_arguments = {'q': list(self.joint_states.position), 'qdot': list(self.joint_states.velocity)}
        runtime_arguments.update(goal_runtime_arguments)
        runtime_arguments.update(self._obstacle_runtime_arguments)
        runtime_arguments.update(state_runtime_arguments)
        return self._planner.compute_action(
            **runtime_arguments,
        )

    def act(self):
        try:
            self.action_message.data = [0, 0] + list(self.compute_action())
            self.action_publisher.publish(self.action_message)
        except Exception as e:
            rospy.loginfo(f"Not planning due to error {e}")
            rospy.loginfo("Waiting for correct planner to be loaded.")
            self.load_planner(self.goal_wrapper._goal_type)


if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
