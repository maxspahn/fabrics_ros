#!/usr/bin/env python3
from typing import List, Union
import time
from mpscenes.goals.sub_goal import SubGoal
import numpy as np
import rospy
import rospkg
import os
import hashlib

from std_msgs.msg import Float64MultiArray, Empty
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, PoseStamped, Quaternion
from urdf_parser_py.urdf import URDF
from fabrics_msgs.msg import (
    FabricsJointSpaceGoal,
    FabricsPoseGoal,
    FabricsConstraintsGoal,
    FabricsObstacleArray,
)
from geometry_msgs.msg import Twist

from mpscenes.goals.goal_composition import GoalComposition
from forwardkinematics.urdfFks.generic_urdf_fk import GenericURDFFk

from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from fabrics.planner.non_holonomic_parameterized_planner import NonHolonomicParameterizedFabricPlanner
from fabrics.planner.serialized_planner import SerializedFabricPlanner

from fabrics_marker_manager import FabricsMarkerManager
from fabrics_goal_evaluator import FabricsGoalEvaluator
from fabrics_goal_wrapper import FabricsGoalWrapper
from visualization_msgs.msg import Marker, MarkerArray

def create_planner(urdf, planner_type: str) -> ParameterizedFabricPlanner:
    base_energy: str = (
        "0.5 * 0.2 * ca.dot(xdot, xdot)"
    )
    collision_geometry: str = (
        "-0.5 / (x ** 2) * xdot ** 2"
    )
    collision_finsler: str = (
        "0.1/(x**2) * (-0.5 * (ca.sign(xdot) - 1)) * xdot**2"
    )
    limit_geometry: str = (
        "-0.50 / (x ** 2) * xdot ** 2"
    )
    limit_finsler: str = (
        "0.4/(x**1) * (-0.5 * (ca.sign(xdot) - 1)) * xdot**2"
    )
    self_collision_geometry: str = (
        "-0.5 / (x ** 1) * (-0.5 * (ca.sign(xdot) - 1)) * xdot ** 2"
    )
    self_collision_finsler: str = (
        "0.1/(x**2) * xdot**2"
    )
    attractor_potential: str = (
        "5.0 * (ca.norm_2(x) + 1 / 10 * ca.log(1 + ca.exp(-2 * 10 * ca.norm_2(x))))"
    )
    attractor_metric: str = (
        "((2.0 - 0.3) * ca.exp(-1 * (0.75 * ca.norm_2(x))**2) + 0.3) * ca.SX(np.identity(x.size()[0]))"
    )
    robot_type = rospy.get_param("/robot_type")
    degrees_of_freedom = rospy.get_param("/degrees_of_freedom")
    forward_kinematics = GenericURDFFk(
        urdf,
        rootLink=rospy.get_param("/root_link"),
        end_link=rospy.get_param("/end_links"),
    )
    if planner_type == "holonomic":
        return ParameterizedFabricPlanner(
            degrees_of_freedom,
            forward_kinematics,
            collision_geometry=collision_geometry,
            collision_finsler=collision_finsler,
            self_collision_finsler=self_collision_finsler,
            limit_geometry=limit_geometry,
            limit_finsler=limit_finsler,
        )
    if planner_type == "nonholonomic":
        collision_geometry: str = (
            "-sym('k_geo_col') / (x ** 1) * xdot ** 2"
        )
        collision_finsler: str = (
            "sym('k_fin_col')/(x**1) * (-0.5 * (ca.sign(xdot) - 1)) * xdot**2"
        )
        return NonHolonomicParameterizedFabricPlanner(
            degrees_of_freedom,
            robot_type,
            urdf=urdf,
            root_link=rospy.get_param("/root_link"),
            end_link=rospy.get_param("/end_links"),
            collision_geometry=collision_geometry,
            collision_finsler=collision_finsler,
            self_collision_finsler=self_collision_finsler,
            limit_geometry=limit_geometry,
            limit_finsler=limit_finsler,
            l_offset=rospy.get_param("/l_offset"),
        )

# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


def list_to_unique_hash(a: list) -> str:
    string = ""
    for value in sorted(a):
        string = string.join(value)
    encoded_string = string.encode("utf-8")
    return hashlib.md5(encoded_string).hexdigest()


Quaternion.__iter__ = _it


class FabricsNode(object):

    _planner : ParameterizedFabricPlanner
    _goal: Union[GoalComposition, None]

    def __init__(self):
        rospy.init_node("fabrics_node")
        self._goal = None
        self._robot_type = rospy.get_param('/robot_type') 
        self.changed_planner = True
        self.stop_acc_bool = True
        self.planners = {}
        self._runtime_arguments = {}
        self.goal_wrapper = FabricsGoalWrapper()
        self.rate = rospy.Rate(100)
        self.load_parameters()
        self.joint_names = rospy.get_param("/joint_names")
        self._index_list = rospy.get_param("/index_list")
        self._planner_type = rospy.get_param("/planner_type")
        if self._planner_type == "nonholonomic":
            self._index_list_qudot = rospy.get_param("/index_list_qudot")
        self.init_publishers()
        self.init_subscribers()
        self.state_evaluator = FabricsGoalEvaluator()
        self.marker_manager = FabricsMarkerManager(self.num_sphere_obstacles, self.collision_bodies, self.collision_links, self.self_collision_pairs)

        #self.init_planner("FabricsJointSpaceGoal")
        #self.init_planner("FabricsPoseGoal")
        self.stop_acc_bool = False
        self.init_runtime_arguments()
        self.compose_runtime_obstacles_argument()
        self._action = np.zeros(9)

    def init_runtime_arguments(self):
        if self._planner_type == 'nonholonomic':
            self._runtime_arguments.update({
                "m_arm": np.array([rospy.get_param("/m_arm")]),
                "m_base_x": np.array([rospy.get_param("/m_base")]),
                "m_base_y": np.array([rospy.get_param("/m_base")]),
                "m_rot": np.array([rospy.get_param("/m_rot")])
            })
            parameters = {}
            k_fin_col = np.array([rospy.get_param("/k_fin_col")])
            k_geo_col = np.array([rospy.get_param("/k_geo_col")])
            for i in range(self.num_sphere_obstacles):
                for collision_link in self.collision_links:
                    parameters[f'k_fin_col_obst_{i}_{collision_link}_leaf'] = k_fin_col
                    parameters[f'k_geo_col_obst_{i}_{collision_link}_leaf'] = k_geo_col
            self._runtime_arguments.update(parameters)
        else:
            self._runtime_arguments = {}

    def load_parameters(self):
        scaling_factor = rospy.get_param('/velocity_scaling')
        self._max_vel = np.array(rospy.get_param("/velocity_limits/upper")) * scaling_factor
        self._min_vel = np.array(rospy.get_param("/velocity_limits/lower")) * scaling_factor
        self.num_sphere_obstacles = rospy.get_param("/num_sphere_obs")
        self.num_box_obstacles = rospy.get_param("/num_box_obs")
        # robot_description should be global because it's not part of fabrics ns
        self.urdf = rospy.get_param(rospy.get_param("/urdf_source"))
        self.collision_links = rospy.get_param("/collision_links")
        try:
            self.self_collision_pairs = rospy.get_param("/self_collision_pairs")
            if self.self_collision_pairs == "None":
                self.self_collision_pairs = {}
        except KeyError as e:
            self.self_collision_pairs = {}
        self.collision_bodies = rospy.get_param("/collision_bodies")
        # TODO: Currently, fabrics require inputs to be np.arrays. This should be chaged to also allow floats.
        for name, radius in self.collision_bodies.items():
            self.collision_bodies[name] = np.array([radius])

    def load_planner(self, goal):
        self.stop_acc_bool = True
        if goal is None:
            return
        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal)
        goal_string = self.goal_wrapper.goal_string(goal)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        # If the planner is not serialized yet, this node has to wait for the serialization to finish.
        try:
            rospy.loginfo(f"Loading planner for goal type : {goal_string}")
            self._planner = self.planners[serialize_file]
            rospy.loginfo(self._planner)
            self.stop_acc_bool = False
        except Exception as e:
            rospy.logwarn(e)
            rospy.loginfo("Planner not found: Waiting...")
            self.init_planner(goal)
            self.stop_acc_bool = False

    def hash_planner_configuration(self, goal: GoalComposition):
        hash_robot_type: str = rospy.get_param("/robot_type")
        hash_sphere_obstacle = hashlib.md5(str(self.num_sphere_obstacles).encode("utf-8")).hexdigest()
        hash_box_obstacle = hashlib.md5(str(self.num_box_obstacles).encode("utf-8")).hexdigest()
        hash_self_collision_pairs = list_to_unique_hash(self.self_collision_pairs)
        hash_collision_links = list_to_unique_hash(self.collision_links)
        hash_goal = self.goal_wrapper.hash_goal(goal)
        return (
            hash_robot_type
            + hash_sphere_obstacle
            + hash_box_obstacle
            + hash_self_collision_pairs
            + hash_collision_links
            + hash_goal
        )

    def init_planner(self, goal: GoalComposition):
        # TODO: Add full body control robot type as an option

        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        if os.path.exists(serialize_file):
            rospy.loginfo(f"Planner is already serialized in {serialize_file}")
            self.planners[serialize_file] = SerializedFabricPlanner(serialize_file)
            return


        goal_string = self.goal_wrapper.goal_string(goal)
        rospy.loginfo(f"Creating the planner for goal:  {goal_string}")
        t0 = time.perf_counter()
        planner = create_planner(self.urdf, self._planner_type)
        # get the joint limits for each joint
        self.robot = URDF.from_parameter_server(rospy.get_param("/urdf_source"))
        joint_limits = []
        for i in self.joint_names:
            joint_limits.append(
                [
                    self.robot.joint_map[i].limit.lower,
                    self.robot.joint_map[i].limit.upper,
                ]
            )
        # The planner hides all the logic behind the function set_components.
        #dummy_goal = self.goal_wrapper.compose_dummy_goal(goal_type)
        planner.set_components(
            collision_links=self.collision_links,
            self_collision_pairs=self.self_collision_pairs,
            goal=goal,
            limits=joint_limits,
            number_obstacles=self.num_sphere_obstacles,
            number_obstacles_cuboid=self.num_box_obstacles,
        )
        planner.concretize(mode='vel', time_step = 1/100)
        t1 = time.perf_counter()
        composition_time = (t1-t0) * 1000
        # serializing the planner
        rospy.loginfo(f"Planner composed in {composition_time} ms")
        goal_string = self.goal_wrapper.goal_string(goal)
        rospy.loginfo(f"Serializing the planner for goal:  {goal_string}")
        t2 = time.perf_counter()
        planner.serialize(serialize_file)
        t3 = time.perf_counter()
        serialize_time = (t3-t2) * 1000
        rospy.loginfo(f"Finished serializing, {serialize_file} has been created in {serialize_time} ms")
        self.planners[serialize_file] = planner


    def run(self):
        while not rospy.is_shutdown():
            # act and evaluate only when a goal, joint_states and a correct planner are received
            if (
                hasattr(self, '_goal')
                and not self.stop_acc_bool
                and not self._goal is None
            ):
                self.act()
                goal_is_reached = self.state_evaluator.evaluate(
                    self._goal_msg, self.joint_states
                )
                self.marker_manager.update_goal_markers(
                    self._goal_msg, goal_is_reached
                )
                self.marker_manager.update_obstacle_markers(
                    self.obstacles
                )
            self.rate.sleep()

    def init_publishers(self):
        self._vel_pub_panda = rospy.Publisher(
            '/panda_joint_velocity_controller/command',
            Float64MultiArray,
            queue_size=10
        )
        self._vel_pub_boxer = rospy.Publisher(
            '/cmd_vel',
            Twist,
            queue_size=10
        )
        """ panda specifics """
        self._vel_msg_panda = Float64MultiArray()
        self._panda_indices = [2, 3, 4, 5, 6, 7, 8]
        """ boxer specifics """
        self._vel_msg_boxer = Twist()
        self._boxer_indices = [0, 1]

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            "planning_obs", FabricsObstacleArray, self.obs_callback,
            tcp_nodelay=True,
        )
        self.obstacles = []
        rospy.Subscriber(
            "joint_space_goal", FabricsJointSpaceGoal, self.joint_space_goal_cb,
            tcp_nodelay=True,
        )
        rospy.Subscriber(
            "ee_pose_goal", FabricsPoseGoal, self.ee_pose_goal_cb,
            tcp_nodelay=True,
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            "/joint_states_filtered",
            JointState,
            self.joint_states_callback,
            tcp_nodelay=True,
        )
        # preempt the previous goal once this cb is triggered
        self.preempt_goal_subscriber = rospy.Subscriber(
            "preempt_goal", Empty, self.preempt_goal_callback
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles
        self._obstacle_runtime_arguments = self.compose_runtime_obstacles_argument()

    def joint_space_goal_cb(self, msg: FabricsJointSpaceGoal):
        self._goal_msg = msg
        self._goal, changed_planner = self.goal_wrapper.wrap(msg)

    def ee_pose_goal_cb(self, msg: FabricsPoseGoal):
        self._goal_msg = msg
        self._goal, changed_planner = self.goal_wrapper.wrap(msg)

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = np.array(msg.name)[self._index_list]
        self.joint_states.position = np.array(msg.position)[self._index_list]
        self.joint_states.velocity = np.array(msg.velocity)[self._index_list]
        if self._planner_type == "nonholonomic":
            self._qudot = np.array(msg.velocity)[self._index_list_qudot]

    def preempt_goal_callback(self, msg: Empty):
        rospy.loginfo(f"goal preempted")
        # only change the weights
        self._goal_msg.weight_goal_0=0
        self._goal_msg.weight_goal_1=0
        self._goal, changed_planner = self.goal_wrapper.wrap(self._goal_msg)

    def compose_runtime_obstacles_argument(self):
        x_obst_sphere = np.full((self.num_sphere_obstacles, 3), [100.0] * 3)
        radius_obst = np.full((self.num_sphere_obstacles, 1), 0.05)
        x_obsts_cuboid = np.full((self.num_box_obstacles, 3), [100.0] * 3)
        size_obsts_cuboid = np.full((self.num_box_obstacles, 3), 0.05)

        for i, o in enumerate(self.obstacles):
            if o.obstacle_type == "sphere":
                if i >= self.num_sphere_obstacles:
                    rospy.logwarn(
                        f"Fabrics planner received more sphere obstacles than it can process: can only handle {self.num_sphere_obstacles}. Consider increasing the rosparameter num_sphere_obstacles."
                    )
                    break
                x_obst_sphere[i, :] = list(o.position)
                radius_obst[i] = o.radius
            elif o.obstacle_type == "box":
                if i >= self.num_box_obstacles:
                    rospy.logwarn(
                        f"Fabrics planner received more box obstacles than it can process: can only handle {self.num_box_obstacles}. Consider increasing the rosparameter num_box_obstacles."
                    )
                    break
                x_obsts_cuboid[i, :] = list(o.position)
                if i == 0:
                    size_obsts_cuboid[0] = o.size.x
                elif i == 1:
                    size_obsts_cuboid[1] = o.size.y
                else: 
                    size_obsts_cuboid[2] = o.size.z
        self._runtime_arguments.update(self.collision_bodies)
        self._runtime_arguments.update({
            'x_obst': x_obst_sphere, 
            'radius_obst': radius_obst,
            'x_obsts_cuboid': x_obsts_cuboid,
            'size_obsts_cuboid': size_obsts_cuboid,
        })


    def compute_action(self):
        self.goal_wrapper.compose_runtime_arguments(self._goal, self._runtime_arguments)
        self._runtime_arguments['q'] = list(self.joint_states.position)
        self._runtime_arguments['qdot'] = list(self.joint_states.velocity)
        if self._planner_type == "nonholonomic":
            self._runtime_arguments['qudot'] =  list(self._qudot)
        return self._planner.compute_action(
            **self._runtime_arguments,
        )

    def act(self):
        try:
            self._action[rospy.get_param("/published_indices")] = self.compute_action()
            self._action = np.clip(self._action, self._min_vel, self._max_vel)
            self._vel_msg_panda.data = self._action.tolist()[2:]
            self._vel_msg_boxer.linear.x = self._action[0]
            self._vel_msg_boxer.angular.z = self._action[1]
            self._vel_pub_panda.publish(self._vel_msg_panda)
            if self._robot_type in ["albert", "boxer"]:
                self._vel_pub_boxer.publish(self._vel_msg_boxer)
        except Exception as e:
            rospy.loginfo(f"Not planning due to error {e}")
            rospy.loginfo("Waiting for correct planner to be loaded.")
            self.load_planner(self._goal)


if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
