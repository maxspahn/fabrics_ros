#!/usr/bin/env python3
import numpy as np
import rospy
import rospkg
import os
import hashlib

import tf
from std_msgs.msg import Float64MultiArray, Bool
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point, PoseStamped, Quaternion
from urdf_parser_py.urdf import URDF
from fabrics_msgs.msg import (
    FabricsGoal,
    FabricsObstacleArray,
)

from MotionPlanningGoal.goalComposition import GoalComposition
from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from fabrics.planner.serialized_planner import SerializedFabricPlanner

from fabrics_marker_manager import FabricsMarkerManager
from fabrics_goal_evaluator import FabricsGoalEvaluator


# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


def list_to_unique_hash(a: list) -> str:
    string = ""
    for value in sorted(a):
        string = string.join(value)
    encoded_string = string.encode("utf-8")
    return hashlib.md5(encoded_string).hexdigest()


Quaternion.__iter__ = _it


class FabricsNode(object):
    def __init__(self):
        rospy.init_node("fabrics_node")
        self._goal_type = ""
        self.rate = rospy.Rate(500)
        self.load_parameters()
        # TODO get the joints list from ListControllers srv
        self.list_joints = [
            "panda_joint1",
            "panda_joint2",
            "panda_joint3",
            "panda_joint4",
            "panda_joint5",
            "panda_joint6",
            "panda_joint7",
        ]
        self.init_publishers()
        self.init_subscribers()

        self.stop_acc_bool = False
        self.init_planner("joint_space")
        self.init_planner("ee_pose")
        rospy.sleep(1.0)

        self.state_evaluator = FabricsGoalEvaluator()
        self.marker_manager = FabricsMarkerManager(self.num_obstacles)

    def load_parameters(self):
        self.num_obstacles = rospy.get_param("/num_obs")
        # robot_description should be global because it's not part of fabrics ns
        self.urdf = rospy.get_param("/robot_description")
        self.collision_links = rospy.get_param("/collision_links")
        self.self_collision_pairs = rospy.get_param("/self_collision_pairs")
        self.collision_bodies = rospy.get_param("/collision_bodies")
        # TODO: Currently, fabrics require inputs to be np.arrays. This should be chaged to also allow floats.
        for name, radius in self.collision_bodies.items():
            self.collision_bodies[name] = np.array([radius])

    def load_planner(self):
        self.stop_acc_bool = True
        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(self._goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        # If the planner is not serialized yet, this node has to wait for the serialization to finish.
        try:
            self._planner = SerializedFabricPlanner(serialize_file)
        except Exception as e:
            rospy.loginfo("Planner not found: Waiting...")
            self._goal_type = ""
            self.stop_acc_bool = True
            return
        self.stop_acc_bool = False

    def hash_planner_configuration(self, goal_type: str):
        hash_obstacle = hashlib.md5(str(self.num_obstacles).encode("utf-8")).hexdigest()
        hash_self_collision_pairs = list_to_unique_hash(self.self_collision_pairs)
        hash_collision_links = list_to_unique_hash(self.collision_links)
        hash_goal_type = hashlib.md5(goal_type.encode("utf-8")).hexdigest()
        return (
            hash_obstacle
            + hash_self_collision_pairs
            + hash_collision_links
            + hash_goal_type
        )

    def init_planner(self, goal_type: str):
        # TODO: Add full body control robot type as an option

        self.planning_goal = self.goal_compose(goal_type)
        rospack = rospkg.RosPack()
        file_hash = self.hash_planner_configuration(goal_type)
        serialize_file = rospack.get_path("fabrics_bridge") + "/planner/" + file_hash
        if os.path.exists(serialize_file):
            rospy.loginfo(f"Planner is already serialized in {serialize_file}")
            return
        robot_type = "panda"
        degrees_of_freedom = 7

        planner = ParameterizedFabricPlanner(
            degrees_of_freedom,
            robot_type,
            urdf=self.urdf,
            root_link="panda_link0",
            end_link=["panda_vacuum_2", "panda_vacuum"],
        )
        # get the joint limits for each joint
        self.robot = URDF.from_parameter_server("/robot_description")
        joint_limits = []
        for i in self.list_joints:
            joint_limits.append(
                [
                    self.robot.joint_map[i].limit.lower,
                    self.robot.joint_map[i].limit.upper,
                ]
            )
        # The planner hides all the logic behind the function set_components.
        planner.set_components(
            self.collision_links,
            self.self_collision_pairs,
            self.planning_goal,
            limits=joint_limits,
            number_obstacles=self.num_obstacles,
        )
        planner.concretize()
        # serializing the planner
        rospy.loginfo(f"Serializing the planner for goal_type:  {goal_type}")
        planner.serialize(serialize_file)
        rospy.loginfo(f"Finished serializing, {serialize_file} has been created")

    def goal_compose(self, goal_type: str):
        joint_space_goal_dict = {
            "joint_position": {
                "m": 7,
                "w": 0.2,  # attractor weight
                "prime": True,
                "indices": list(range(7)),
                "desired_position": [0.0, 0.0, 0.0, -1.501, 0.0, 0.8675, 0.0],
                "epsilon": 0.01,
                "type": "staticJointSpaceSubGoal",
            }
        }
        ee_pose_goal_dict = {
            "position": {
                "m": 3,
                "w": 0.15,  # attractor weight
                "prime": True,
                "indices": [0, 1, 2],
                "parent_link": "panda_link0",
                "child_link": "panda_vacuum",
                "desired_position": [0.5, 0.0, 0.5],
                "epsilon": 0.01,
                "type": "staticSubGoal",
            },
            "orientation": {
                "m": 2,
                "w": 0.3,  # attractor weight
                "prime": False,
                "indices": [0, 1],
                "parent_link": "panda_hand",
                "child_link": "panda_vacuum",
                "angle": [0.707, 0.0, 0.0, 0.707],
                "desired_position": [0.0, 0.0],
                "epsilon": 0.01,
                "type": "staticSubGoal",
            },
        }
        if goal_type == "ee_pose":
            goal_dict = ee_pose_goal_dict
        elif goal_type == "joint_space":
            goal_dict = joint_space_goal_dict
        planning_goal = GoalComposition(name="goal", contentDict=goal_dict)
        return planning_goal

    def run(self):
        while not rospy.is_shutdown():
            # act and evaluate only when a goal, joint_states and a correct planner are received
            if (
                hasattr(self, "goal")
                and len(self.joint_states.name) > 0
                and not self.stop_acc_bool
            ):
                self.act()
                goal_is_reached = self.state_evaluator.evaluate(
                    self.goal, self.joint_states
                )
                self.marker_manager.update_markers(
                    self.goal, self.obstacles, goal_is_reached
                )
            self.rate.sleep()

    def init_publishers(self):
        self.action_message = Float64MultiArray(data=np.zeros(9))
        self.action_publisher = rospy.Publisher(
            "/joint_acc_des", Float64MultiArray, queue_size=10
        )

    def init_subscribers(self):
        self.obs_subscriber = rospy.Subscriber(
            "planning_obs", FabricsObstacleArray, self.obs_callback
        )
        self.obstacles = []
        self.goal_subscriber = rospy.Subscriber(
            "planning_goal", FabricsGoal, self.goal_callback
        )
        self.joint_states = JointState()
        self.joint_state_subscriber = rospy.Subscriber(
            "/joint_states_filtered",
            JointState,
            self.joint_states_callback,
            tcp_nodelay=True,
        )
        # stop publishing joint_acc_des once the cb is triggered
        self.acc_stop_subscriber = rospy.Subscriber(
            "acc_stop_request", Bool, self.acc_stop_callback
        )

    def obs_callback(self, msg: FabricsObstacleArray):
        self.obstacles = msg.obstacles

    def goal_callback(self, msg: FabricsGoal):
        if not self._goal_type == msg.goal_type:
            self._goal_type = msg.goal_type
            self.load_planner()
        if self._goal_type == "ee_pose":
            self.goal = msg.goal_pose
        elif self._goal_type == "joint_space":
            self.goal = msg.goal_joint_state
        else:
            rospy.loginfo("Please specify a goal type, either ee_pose or joint_space")
            return
        self.goal_weight_goal_0 = msg.weight_goal_0
        self.goal_weight_goal_1 = msg.weight_goal_1

    def joint_states_callback(self, msg: JointState):
        # TODO: better way of extracting just the panda joint states
        self.joint_states.name = msg.name[5:]
        self.joint_states.position = msg.position[5:]
        self.joint_states.velocity = msg.velocity[5:]

    def acc_stop_callback(self, msg: Bool):
        self.stop_acc_bool = msg.data

    def parse_ee_pose_goal(self):
        euler_goal = list(
            tf.transformations.euler_from_quaternion(
                list(self.goal.pose.orientation), "rxyz"
            )
        )
        rot_mat = tf.transformations.euler_matrix(
            -euler_goal[1], -euler_goal[0], 0, "ryxz"
        )[:3, :3]
        goal_args = {
            "x_goal_0": list(self.goal.pose.position),
            "x_goal_1": np.array([0.0, 0.0]),
            "angle_goal_1": rot_mat,
            "weight_goal_1": np.array(self.goal_weight_goal_1),
            "weight_goal_0": np.array(self.goal_weight_goal_0),
        }
        return goal_args

    def parse_joint_space_goal(self):
        return {
            "x_goal_0": np.array(self.goal.position),
            "weight_goal_0": np.array(self.goal_weight_goal_0),
        }

    def compute_action(self):
        # Ensure right number of obstacles, if less are received fill with [100, 100, 100], if more received naively take the first ones.
        x_obst = np.full((self.num_obstacles, 3), [100.0] * 3)
        radius_obst = np.full((self.num_obstacles, 1), 0.05)
        for i, o in enumerate(self.obstacles):
            if i >= self.num_obstacles:
                rospy.logwarn(
                    f"Fabrics planner received more obstacles that it can process by the client: received {len(self.obstacles)} but can only handle {self.num_obstacles}.Consider increasing the rosparameter num_obstacles."
                )
                break
            x_obst[i, :] = list(o.position)
            radius_obst[i] = o.radius
        if isinstance(self.goal, PoseStamped):
            goal_args = self.parse_ee_pose_goal()
        elif isinstance(self.goal, JointState):
            goal_args = self.parse_joint_space_goal()
        goal_args.update(self.collision_bodies)
        return self._planner.compute_action(
            q=list(self.joint_states.position),
            qdot=list(self.joint_states.velocity),
            x_obst=x_obst,
            radius_obst=radius_obst,
            **goal_args,
        )

    def act(self):
        self.action_message.data = [0, 0] + list(self.compute_action())
        self.action_publisher.publish(self.action_message)


if __name__ == "__main__":
    my_fabric_node = FabricsNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
