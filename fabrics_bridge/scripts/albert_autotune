#!/usr/bin/env python3

# ros imports
import rospy
import tf
import numpy as np
from fabrics_msgs.msg import FabricsGoal, FabricsObstacleArray, FabricsObstacle, FabricsState
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from std_msgs.msg import Empty

from pynput.keyboard import Listener,KeyCode
import joblib
import optuna
import quaternionic

from fabrics_bridge.rectangle_spheres import *
from fabrics_bridge.optuna_node import OptunaNode

"""
def generate_random_orientation(w_amp, z_amp):
    quat_array =  np.array([-0.707 + np.random.random(1)[0] * w_amp, 0, -0.707 + np.random.random(1)[0] * z_amp, 0])
    return quat_array/np.linalg.norm(quat_array)
"""

def generate_random_orientation(mean, rotation=0.0, tilting=0.0):
    """
    Generate random orientation of feasible reaching tasks.

    params
    mean:list
        mean of quaternion, good: mean = [0.0, 0.707, 0.0, 0.0]
    rotation: float
        amount of rotation around z axis
    tilting: float
        amount of tilting
    """
    lower_limit = np.array([0, 0, -rotation, -tilting])
    upper_limit = np.array([0, 0, rotation, tilting])
    orientation = np.array(mean) + np.random.uniform(lower_limit, upper_limit, 4)
    orientation /= np.linalg.norm(orientation)
    return orientation.tolist()

def generate_random_position():
    return np.random.uniform(np.array([2.7, -1.2, 1.0]), np.array([3.3, 1.2, 2.0]), 3)



class AlbertOptunaNode(OptunaNode):
    def __init__(self):
        super().__init__()
        self._obstacle_resolution = 10
        self._indices = rospy.get_param("/index_list")
        self.tf_listener = tf.TransformListener()
        self._static_goal_orientation = [-0.707, 0.1, -0.707, 0.05] #[0.3, 0.707, 0.15, 0.0]
        self._static_goal_orientation /= np.linalg.norm(self._static_goal_orientation)
        self._static_goal_position = [2.59, -1.15, 1.36]
        self._static_ring_orientation = [-0.707, -0.1, -0.707, -0.2] #[-0.10, 0.71, -0.20, 0.0]
        self._static_ring_orientation /= np.linalg.norm(self._static_ring_orientation)
        self._joint_positions = np.array(10)
        self._old_joint_positions = np.array(10)

    def joint_state_cb(self, state: JointState):
        self._joint_positions = np.array(state.position)[self._indices]

    def initialize_home_goal(self):
        self._home_goal = FabricsGoal()
        self._home_goal.goal_joint_state.header.stamp = rospy.Time.now()
        self._home_goal.goal_joint_state.name = ['world_base_x', 'world_base_y', 'world_base_theta'] + [f"panda_joint{i}" for i in range(7)]
        #self._home_goal.goal_joint_state.position = [0.0, 0.0, 0.0, -0.9, 0.0, -1.501, 0.0, 1.8675, 0.0]
        self._home_goal.goal_joint_state.position = [0.0, 0.0, 1.0, 0.0, -1.0, 0.0, -1.501, 0.0, 1.8675, 0.0]
        self._home_goal.goal_type = "joint_space"
        self._home_goal.weight_goal_0 = 1.0
        self._home_goal.tolerance_goal_0 = 0.20

    def reset_parameters(self):
        super().reset_parameters()
        rospy.set_param('/fabrics_geometries/m_base', 1.00)
        rospy.set_param('/fabrics_geometries/m_rot', 0.4)
        rospy.set_param('/fabrics_geometries/l_offset', 0.25)
        rospy.set_param('/fabrics_geometries/m_arm', 5.0)

    def sample_fabrics_params(self, trial):
        super().sample_fabrics_params(trial)
        self.sample_parameter(trial, ['m_base'], [0.0, 10.00])
        self.sample_parameter(trial, ['l_offset'], [0.0, 1.00])
        self.sample_parameter(trial, ['m_rot'], [0.0, 10.00])
        self.sample_parameter(trial, ['m_arm'], [0.0, 10.00])

    def publish_goal(self):
        self.goal = FabricsGoal()
        if self._randomize:
            mean = [-0.707, 0, -0.707, 0.0]
            self._goal_orientation = generate_random_orientation(mean, rotation=0.1, tilting=0.1)
            position = generate_random_position()
        else:
            self._goal_orientation = self._static_goal_orientation
            position = self._static_goal_position
        self.goal.goal_pose.pose.position.x = position[0]
        self.goal.goal_pose.pose.position.y = position[1]
        self.goal.goal_pose.pose.position.z = position[2]
        self.goal.goal_pose.header.frame_id = "odom"
        self.goal.goal_pose.pose.orientation.w = self._goal_orientation[0]
        self.goal.goal_pose.pose.orientation.x = self._goal_orientation[1]
        self.goal.goal_pose.pose.orientation.y = self._goal_orientation[2]
        self.goal.goal_pose.pose.orientation.z = self._goal_orientation[3]
        self.goal.goal_type = "ee_pose"
        self.goal.weight_goal_0 = 1.0 * self._gazebo_factor
        self.goal.weight_goal_1 = 6.0 * self._gazebo_factor
        self.goal.tolerance_goal_0 = 0.02
        self.goal.tolerance_goal_1 = 0.02
        for _ in range(10):
            self._goal_publisher.publish(self.goal)

    # returns points on circumference of a circle, i.e. center of each sphere
    def ring_spheres(self):
        self.obs = FabricsObstacleArray()
        if self._randomize:
            ring_orientation = generate_random_orientation(self._goal_orientation, rotation=0.1, tilting=0.1)
        else:
            ring_orientation = self._static_ring_orientation
        rotation_matrix_ring = quaternionic.array(ring_orientation).to_rotation_matrix
        whole_position = np.array(
                [
                    self.goal.goal_pose.pose.position.x,
                    self.goal.goal_pose.pose.position.y,
                    self.goal.goal_pose.pose.position.z
                ]
            )
        radius_ring = 0.27
        for i in range(self._obstacle_resolution + 1):
            angle = i/self._obstacle_resolution * 2.*np.pi
            origin_position = [
                radius_ring * np.cos(angle),
                radius_ring * np.sin(angle),
                0.05,
            ]
            position = np.dot(np.transpose(rotation_matrix_ring), origin_position) + whole_position
            obstacle = FabricsObstacle()
            obstacle.header.frame_id = "odom"
            obstacle.radius = 0.08
            obstacle.position = Point(x=position[0], y=position[1], z=position[2])
            self.obs.obstacles.append(obstacle)
        # shelf obstacles
        for i in range(4):
            obstacle_1 = FabricsObstacle()
            obstacle_1.header.frame_id = "odom"
            obstacle_1.radius = 0.5
            obstacle_1.position = Point(x=3.0, y=-1.5 + i * 0.75, z=0.0)
            self.obs.obstacles.append(obstacle_1)
        self._obs_publisher.publish(self.obs)


    def evaluate_distance_to_goal(self, goal_position: np.ndarray):
        return np.linalg.norm(goal_position - self.get_current_pose(rospy.get_param("/end_effector_link"))) / self._initial_distance_to_goal

    def objective(self, trial=None):
        self.return_home()
        if self.stopped():
            return {"path_length": 1.0, "time_to_goal": 1.0, "obstacles": 1.0}
        if trial:
            self.sample_fabrics_params(trial)
        else:
            self.select_best_params()
        self._manually_ended = False
        self.publish_goal()
        self.ring_spheres()
        self.create_collision_metric(self.obs)
        # Initialize costs
        goal_position = np.array([self.goal.goal_pose.pose.position.x, self.goal.goal_pose.pose.position.y, self.goal.goal_pose.pose.position.z])
        self._initial_distance_to_goal = np.linalg.norm(self.get_current_pose(rospy.get_param("/end_effector_link")) - goal_position)
        initial_distance_to_obstacles = self.evaluate_distance_to_closest_obstacle(self.obs, self._joint_positions)
        distances_to_goal = []
        distances_to_closest_obstacle = []
        path_length = 0.0
        start = rospy.Time.now().to_sec()
        rospy.loginfo(f"Starting trial at {start}")
        x_old = self._joint_positions
        while (rospy.Time.now().to_sec() - start) < self._maximum_seconds:
            self._goal_publisher.publish(self.goal)
            path_length += np.linalg.norm(self._joint_positions - x_old)
            x_old = self._joint_positions
            distances_to_goal.append(self.evaluate_distance_to_goal(goal_position))
            distances_to_closest_obstacle.append(self.evaluate_distance_to_closest_obstacle(self.obs, self._joint_positions))
            if self._manually_ended:
                return {"path_length": 1.0, "time_to_goal": 1.0, "obstacles": 1.0}
            self._rate.sleep()
        costs = {
            "path_length": path_length/10,
            "time_to_goal": np.mean(np.array(distances_to_goal)),
            "obstacles": 1 - np.min(distances_to_closest_obstacle) / initial_distance_to_obstacles
        }
        rospy.loginfo(f"Finished trial with costs {costs}")
        return costs

if __name__ == "__main__":
    optuna_node = AlbertOptunaNode()
    try:
        optuna_node.run()
    except rospy.ROSInterruptException:
        pass
