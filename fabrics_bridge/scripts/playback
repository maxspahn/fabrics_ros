#!/usr/bin/env python3
import sys
import rospy
import actionlib
import numpy as np
import pickle
import tf
import tf2_ros
from itertools import cycle

from fabrics_msgs.msg import (
    FabricsState,
    FabricsObstacleArray,
    FabricsObstacle,
    FabricsGoal,
)
from geometry_msgs.msg import PoseStamped, Point, Quaternion, Pose
from std_msgs.msg import Bool, Header

class Recording():
    def __init__(self, ee_name, name):
        self._data = []
        self._ee_name = ee_name
        self._name = name

    def append_waypoint(self, waypoint: list) -> None:
        self._data.append(waypoint)

    def waypoints(self) -> list:
        return self._data

    def save(self):
        with open(f"{self._name}.pickle", "wb") as f:
            pickle.dump(self, f)
        rospy.loginfo(f"Saved {len(self._data)} poses to {self._name}.pickle")

# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


Quaternion.__iter__ = _it


class PlaybackWaypoints(object):
    def __init__(self, name: str, base_frame: str) -> None:
        # Initialize action server
        self._rate = rospy.Rate(20)

        # Start listener
        self.tf_listener = tf.TransformListener()
        self.tf2_buffer = tf2_ros.Buffer()
        self.tf2_listener = tf2_ros.TransformListener(self.tf2_buffer)
        self.tf2_broadcaster = tf2_ros.StaticTransformBroadcaster()
        rospy.sleep(1.0)

        # Initialize publishers/subscribers/clients
        self.init_publishers()
        self.init_subscribers()

        # initialize goal
        # it's a goal wrt panda_link0
        self.goal = FabricsGoal(goal_type="ee_pose")
        self._base_frame = base_frame
        self.goal.goal_pose.header.frame_id = base_frame
        self.goal.weight_goal_0 = 0.5
        self.goal.weight_goal_1 = 1.0
        self.goal.tolerance_goal_0 = 0.03
        self.goal.tolerance_goal_1 = 5*(3.14/180)

    def init_publishers(self):
        self.fabrics_goal_pub = rospy.Publisher(
            "/fabrics/planning_goal", FabricsGoal, queue_size=10
        )

    def init_subscribers(self):
        self.fabrics_state_sub = rospy.Subscriber(
            "/fabrics/state", FabricsState, self.fabrics_state_cb
        )
        self.fabrics_state = FabricsState(goal_reached=False, positional_error=100.0)


    def fabrics_state_cb(self, msg):
        self.fabrics_state = msg

    def reach_waypoint(self, pose, check_present=False) -> bool:
        pose.header.stamp = rospy.Time(0)
        goal_pose = self.tf_listener.transformPose(
            self._base_frame, pose
        )
        self.goal.goal_pose.pose = goal_pose.pose

        start = rospy.Time().now()
        min_time_passed = lambda: rospy.Time().now() - start > rospy.Duration(0.01)
        max_time_passed = lambda: rospy.Time().now() - start > rospy.Duration(20)

        self.fabrics_goal_pub.publish(self.goal)
        while not self.fabrics_state.goal_reached or not min_time_passed():
            self.fabrics_goal_pub.publish(self.goal)
            self._rate.sleep()
        return True


    def run(self, waypoints):
        for pose in cycle(waypoints):
            #pose.header.frame_id="tag_2_filtered"
            self.reach_waypoint(pose)

if __name__ == "__main__":
    with open(sys.argv[1], 'rb') as f:
        recording: Recording = pickle.load(f)

    waypoints = recording.waypoints()

    rospy.init_node("playback_waypoints")
    node = PlaybackWaypoints(rospy.get_name(), base_frame='/panda_link0')
    node.run(waypoints)
