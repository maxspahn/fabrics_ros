#!/usr/bin/env python3
import os
import sys
import rospy
import actionlib
import numpy as np
import pickle
import tf
import tf2_ros
from pynput import keyboard
from itertools import cycle

from fabrics_msgs.msg import (
    FabricsState,
    FabricsObstacleArray,
    FabricsObstacle,
    FabricsGoal,
)
from geometry_msgs.msg import Point, Quaternion, PoseStamped
from std_msgs.msg import Float64MultiArray
from albert_vacuum_gripper.msg import DropOffActionGoal, VacuumActionGoal

from record import Recording


# Helpers
def _it(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it


def _it(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


Quaternion.__iter__ = _it


class PlaybackWaypoints(object):
    def __init__(self, recording: Recording, base_frame: str) -> None:
        # Initialize action server
        self._rate = rospy.Rate(10)
        self._target_frame = "panda_link0"
        self._ee_frame = "panda_vacuum"
        self._vacuum = False

        self.establish_ros_connections()
        self._recording = recording


        # initialize goal
        # it's a goal wrt panda_link0
        self.goal = FabricsGoal(goal_type="ee_pose")
        self._base_frame = base_frame
        self.goal.goal_pose.header.frame_id = base_frame
        self.goal.tolerance_goal_0 = 0.05
        self.goal.tolerance_goal_1 = 10*(3.14/180)
        self.set_controller()
        self._listener = keyboard.Listener(
                on_press=self.keyboard_cb,
        )
        self._listener.start()
        self._weight_factor = 1
        self._threshold_factor = 1
        self._remove_point = False

    def keyboard_cb(self, event):
        if event == keyboard.KeyCode.from_char("w"):
            self._weight_factor *= 1.1
        if event == keyboard.KeyCode.from_char("v"):
            self._weight_factor *= 0.99
        if event == keyboard.KeyCode.from_char("t"):
            self._threshold_factor *= 1.1
        if event == keyboard.KeyCode.from_char("s"):
            self._threshold_factor *= 0.99
        if event == keyboard.KeyCode.from_char("r"):
            self._remove_point = True

    def establish_ros_connections(self):
        # Start listener
        self.tf_listener = tf.TransformListener()
        self.tf2_buffer = tf2_ros.Buffer()
        self.tf2_listener = tf2_ros.TransformListener(self.tf2_buffer)
        self.tf2_broadcaster = tf2_ros.StaticTransformBroadcaster()
        # Initialize publishers/subscribers/clients
        self.init_publishers()
        self.init_subscribers()
        rospy.sleep(1.0)

    def init_publishers(self):
        self.fabrics_goal_pub = rospy.Publisher(
            "/fabrics/planning_goal", FabricsGoal, queue_size=10
        )
        self._ki_publisher = rospy.Publisher(
            "/compliant_joint_velocity_controller/controller_ki",
            Float64MultiArray,
            queue_size=1
        )
        self._kp_publisher = rospy.Publisher(
            "/compliant_joint_velocity_controller/controller_kp",
            Float64MultiArray,
            queue_size=1
        )
        self._suck_publisher = rospy.Publisher("/franka_vacuum_gripper/vacuum/goal", VacuumActionGoal, queue_size=1)
        self._unsuck_publisher = rospy.Publisher("/franka_vacuum_gripper/dropoff/goal", DropOffActionGoal, queue_size=1)

    def init_subscribers(self):
        self.fabrics_state_sub = rospy.Subscriber(
            "/fabrics/state", FabricsState, self.fabrics_state_cb
        )
        self.fabrics_state = FabricsState(goal_reached=False, positional_error=100.0)

    def suck(self):
        goal_msg = VacuumActionGoal()
        goal_msg.goal.vacuum = 1
        self._suck_publisher.publish(goal_msg)

    def unsuck(self):
        goal_msg = DropOffActionGoal()
        self._unsuck_publisher.publish(goal_msg)


    def fabrics_state_cb(self, msg):
        self.fabrics_state = msg

    def index(self, name):
        return self._recording._indices[name]

    def publish_waypoint_goal(self, waypoint_index):
        if self._remove_point:
            rospy.loginfo(f"Removing waypoint {waypoint_index}")
            self._recording.remove_waypoint(waypoint_index)
            self._remove_point = False
        waypoint = self._recording.waypoints()[waypoint_index]

        position = waypoint[self.index('position')[0]: self.index('position')[1]]
        orientation = waypoint[self.index('orientation')[0]: self.index('orientation')[1]]
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.x = orientation[0]
        pose.pose.orientation.y = orientation[1]
        pose.pose.orientation.z = orientation[2]
        pose.pose.orientation.w = orientation[3]
        pose.header = waypoint[self.index('header')]
        pose.header.stamp = rospy.Time(0)
        goal_pose = self.tf_listener.transformPose(
            self._base_frame, pose
        )
        self.goal.goal_pose.pose = goal_pose.pose
        weight_0 = waypoint[self.index('weight_0')] * self._weight_factor
        weight_1 = waypoint[self.index('weight_1')] * self._weight_factor
        threshold_0 = waypoint[self.index('tolerance_0')] * self._threshold_factor
        self.goal.weight_goal_0 = weight_0
        self.goal.weight_goal_1 = weight_1
        self.goal.tolerance_goal_0 = threshold_0
        rospy.loginfo(waypoint[self.index('vacuum')])
        if self._vacuum != waypoint[self.index('vacuum')]:
            if waypoint[self.index('vacuum')]:
                self._vacuum = True
                self.suck()
            else:
                self._vacuum = False
                self.unsuck()


        rospy.loginfo(f"Publishing goal for waypoint {waypoint_index} with weight {weight_0} and tolerance {threshold_0}")
        self.fabrics_goal_pub.publish(self.goal)
        self._recording.change_value_at_waypoint(waypoint_index, 'weight_0', weight_0)
        self._recording.change_value_at_waypoint(waypoint_index, 'tolerance_0', threshold_0)


    def execute_trajectory(self, step_size: int):
        waypoint_index = 0
        while waypoint_index < len(self._recording.waypoints()):
            self.publish_waypoint_goal(waypoint_index)
            self._rate.sleep()
            if self.fabrics_state.goal_reached:
                closest_waypoint = waypoint_index
            else:
                closest_waypoint = self.get_closest_waypoint_index()

            closest_waypoint = max(closest_waypoint, waypoint_index)
            closest_waypoint = min(closest_waypoint + step_size, waypoint_index)
            waypoint_index = min(len(self._recording.waypoints()), closest_waypoint + step_size)
            """
            closest_waypoint = max(closest_waypoint, waypoint_index)
            distances = np.linalg.norm(self._positions[closest_waypoint, :] -
                                       self._positions[closest_waypoint+1:, :],
                                       axis = 1)
            rospy.loginfo(distances.shape)
            try:
                waypoint_index = np.where(distances > step_size)[0][0] + closest_waypoint
            except IndexError:
                waypoint_index = len(self._recording.waypoints())
            """


    def reach_waypoint(self, waypoint_index: int, check_present=False) -> bool:
        waypoint = self._recording.waypoints()[waypoint_index]
        position = waypoint[self.index('position')[0]: self.index('position')[1]]
        orientation = waypoint[self.index('orientation')[0]: self.index('orientation')[1]]
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.x = orientation[0]
        pose.pose.orientation.y = orientation[1]
        pose.pose.orientation.z = orientation[2]
        pose.pose.orientation.w = orientation[3]
        pose.header = waypoint[self.index('header')]
        pose.header.stamp = rospy.Time(0)
        goal_pose = self.tf_listener.transformPose(
            self._base_frame, pose
        )
        self.goal.goal_pose.pose = goal_pose.pose

        start = rospy.Time().now()
        min_time_passed = lambda: rospy.Time().now() - start > rospy.Duration(0.005)
        max_time_passed = lambda: rospy.Time().now() - start > rospy.Duration(20)

        self.fabrics_goal_pub.publish(self.goal)
        weight_0 = waypoint[self.index('weight_0')] * self._weight_factor
        weight_1 = waypoint[self.index('weight_0')] * self._weight_factor
        threshold_0 = waypoint[self.index('tolerance_0')] * self._threshold_factor
        while not self.fabrics_state.goal_reached or not min_time_passed():
            weight_0 = waypoint[self.index('weight_0')] * self._weight_factor
            weight_1 = waypoint[self.index('weight_0')] * self._weight_factor
            threshold_0 = waypoint[self.index('tolerance_0')] * self._threshold_factor
            self.goal.weight_goal_0 = weight_0
            self.goal.weight_goal_1 = weight_1
            self.goal.tolerance_goal_0 = threshold_0
            #rospy.loginfo(f"{self.goal.tolerance_goal_0}, {self.goal.weight_goal_0}")
            self.fabrics_goal_pub.publish(self.goal)
            self._rate.sleep()
        self._recording.change_value_at_waypoint(waypoint_index, 'weight_0', weight_0)
        self._recording.change_value_at_waypoint(waypoint_index, 'tolerance_0', threshold_0)
        return True

    def get_closest_waypoint_index(self) -> int:
        position_found = False
        while not position_found:
            try:
                trans = self.tf2_buffer.lookup_transform(
                    self._target_frame, self._ee_frame, rospy.Time()
                )
                position_found = True
            except (
                tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException,
            ):
                rospy.logwarn("Could not get transform")
                continue

        # Convert the transform to a PoseStamped message and add it to the list
        cur_position = trans.transform.translation
        position = np.array([cur_position.x, cur_position.y, cur_position.z])
        positions = np.array([d[0:3] for d in self._recording._data])
        distances = np.linalg.norm(position - positions, axis=1)
        return np.argmin(distances)


    def set_controller(self):
        kp = [10, 20, 30, 40, 10, 10, 5]
        ki = [2, 2, 2, 2, 0.5, 1, 0.5]
        ki_msg = Float64MultiArray(data=ki)
        kp_msg = Float64MultiArray(data=kp)
        rospy.loginfo("Setting low controller gains.")
        for i in range(10):
            self._ki_publisher.publish(ki_msg)
            self._kp_publisher.publish(kp_msg)


    def run(self):
        start = rospy.Time().now()
        waypoints = self._recording.waypoints()
        self.execute_trajectory(1)
        #for pose in cycle(waypoints):
        """
        for waypoint_index in range(len(waypoints)):
            #pose.header.frame_id="tag_2_filtered"
            self.reach_waypoint(waypoint_index)
        """
        self._recording.name(f"{self._recording._name}_improved")
        self._recording.save()

        end = rospy.Time().now()
        duration = end - start
        rospy.loginfo(duration.to_sec())
if __name__ == "__main__":
    with open(sys.argv[1], 'rb') as f:
        recording: Recording = pickle.load(f)


    rospy.init_node("playback_waypoints")
    node = PlaybackWaypoints(recording=recording, base_frame='/panda_link0')
    node.run()
