#!/usr/bin/env python3
# general python imports
import numpy as np
import math
import time
import tf

# ros imports
import rospy
from geometry_msgs.msg import PoseStamped, Point, Quaternion, Vector3
from fabrics_msgs.msg import (
    FabricsGoal,
    FabricsGoalArray,
    FabricsObstacle,
    FabricsObstacleArray,
)

# Helper functions for making Point and Quaternion iterable
def _it_point(self):
    yield self.x
    yield self.y
    yield self.z


Point.__iter__ = _it_point


def _it_quat(self):
    yield self.x
    yield self.y
    yield self.z
    yield self.w


Quaternion.__iter__ = _it_quat


class ClientNode(object):
    def __init__(self):
        rospy.init_node("client_node")
        self._rate = rospy.Rate(10)
        # default number of obstacles is 20
        self._num_obs = 0
        self._num_obs_cuboid = 2
        self.init_publishers()
        self._goal = FabricsGoal()
        # xyz size of the cuboid obstacle
        self.size_cuboid = Vector3(x=0.20, y=0.5, z=0.05)
        self.positions_cuboids = np.array([
            [1.0, 0.2, 1.0],
            [0.5, 0.2, 0.4],
        ])
        self.obs = FabricsObstacleArray()

    def init_publishers(self):
        self._goal_publisher = rospy.Publisher(
            "fabrics/planning_goal", FabricsGoal, queue_size=10
        )
        self._obs_publisher = rospy.Publisher(
            "fabrics/planning_obs", FabricsObstacleArray, queue_size=10
        )

    # cuboids to construct shelves
    def cuboid_shelves(self, pose):

        rot_matrix = tf.transformations.quaternion_matrix(list(pose.pose.orientation))[
            :3, :3
        ]
        initial_cuboids = np.array(
            [
                [
                    self.r_shelf_cuboid * np.cos(i * 2 * np.pi / self._num_obs_cuboid),
                    self.r_shelf_cuboid * np.sin(i * 2 * np.pi / self._num_obs_cuboid),
                    -0.1,
                ]
                for i in range(self._num_obs)
            ]
        )
        cuboids = np.matmul(rot_matrix, initial_cuboids.T).T + list(
            pose.pose.position
        )
        return cuboids

    def append_obstacles_cuboids(self):
        for i in range(self._num_obs_cuboid):
            o = FabricsObstacle()
            o.header.frame_id = rospy.get_param("/root_link")
            o.obstacle_type = "box"
            # o.radius = self.r_obs
            o.size = self.size_cuboid
            o.position = Point(
                x=self.positions_cuboids[i, 0],
                y=self.positions_cuboids[i, 1],
                z=self.positions_cuboids[i, 2],
            )
            self.obs.obstacles.append(o)
        return self.obs

    def publish_goal(
        self, pos_x, pos_y, pos_z, quat_x, quat_y, quat_z, quat_w, weight_0, weight_1
    ):
        self._goal.goal_pose.pose.position = Point(x=pos_x, y=pos_y, z=pos_z)
        self._goal.goal_pose.pose.orientation = Quaternion(
            x=quat_x, y=quat_y, z=quat_z, w=quat_w
        )
        self._goal.goal_pose.header.frame_id = rospy.get_param("/root_link")
        self._goal.goal_type = "ee_pose"
        self._goal.weight_goal_0 = weight_0
        self._goal.weight_goal_1 = weight_1
        self._goal_publisher.publish(self._goal)

    def publish_obs(self):
        self.obs.obstacles = []
        self.append_obstacles_cuboids()
        self._obs_publisher.publish(self.obs)

    def run(self):
        while not rospy.is_shutdown():
            self.publish_goal(
                0.8, 0.2, 0.70, 0, -0.7071067811865475, 0, -0.7071067811865475, 2, 7
            )
            self.publish_obs()
            self._rate.sleep()


if __name__ == "__main__":
    client_node = ClientNode()
    try:
        client_node.run()
    except rospy.ROSInterruptException:
        pass
