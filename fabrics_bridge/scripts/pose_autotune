#!/usr/bin/env python3

# ros imports
import rospy
import tf
from fabrics_msgs.msg import FabricsGoal, FabricsObstacleArray, FabricsObstacle, FabricsState
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from std_msgs.msg import Empty

from pynput.keyboard import Listener,KeyCode
import joblib
import optuna
import quaternionic

from fabrics_bridge.rectangle_spheres import *
from fabrics_bridge.optuna_node import OptunaNode

"""
def generate_random_orientation(w_amp, z_amp):
    quat_array =  np.array([-0.707 + np.random.random(1)[0] * w_amp, 0, -0.707 + np.random.random(1)[0] * z_amp, 0])
    return quat_array/np.linalg.norm(quat_array)
"""

def generate_random_orientation(mean, rotation=0.0, tilting=0.0):
    """
    Generate random orientation of feasible reaching tasks.

    params
    mean:list
        mean of quaternion, good: mean = [0.0, 0.707, 0.0, 0.0]
    rotation: float
        amount of rotation around z axis
    tilting: float
        amount of tilting
    """
    lower_limit = np.array([0, 0, -rotation, -tilting])
    upper_limit = np.array([0, 0, rotation, tilting])
    orientation = np.array(mean) + np.random.uniform(lower_limit, upper_limit, 4)
    orientation /= np.linalg.norm(orientation)
    return orientation.tolist()

def generate_random_position():
    return np.random.uniform(np.array([0.5, -0.2, 0.6]), np.array([0.7, 0.2, 0.7]), 3)



class PoseOptunaNode(OptunaNode):
    def __init__(self):
        super().__init__()
        self._obstacle_resolution = 10
        self.tf_listener = tf.TransformListener()
        self._static_goal_orientation = [-0.707, 0.3, -0.707, 0.15] #[0.3, 0.707, 0.15, 0.0]
        self._static_goal_orientation /= np.linalg.norm(self._static_goal_orientation)
        self._static_goal_position = [0.59, 0.15, 0.76]
        self._static_ring_orientation = [-0.707, -0.1, -0.707, -0.2] #[-0.10, 0.71, -0.20, 0.0]
        self._static_ring_orientation /= np.linalg.norm(self._static_ring_orientation)
        self._randomize = True


    def publish_goal(self):
        self.goal = FabricsGoal()
        if self._randomize:
            mean = [-0.707, 0, -0.707, 0.0]
            self._goal_orientation = generate_random_orientation(mean, rotation=0.1, tilting=0.1)
            position = generate_random_position()
        else:
            self._goal_orientation = self._static_goal_orientation
            position = self._static_goal_position
        self.goal.goal_pose.pose.position.x = position[0]
        self.goal.goal_pose.pose.position.y = position[1]
        self.goal.goal_pose.pose.position.z = position[2]
        self.goal.goal_pose.header.frame_id = "panda_link0"
        self.goal.goal_pose.pose.orientation.w = self._goal_orientation[0]
        self.goal.goal_pose.pose.orientation.x = self._goal_orientation[1]
        self.goal.goal_pose.pose.orientation.y = self._goal_orientation[2]
        self.goal.goal_pose.pose.orientation.z = self._goal_orientation[3]
        self.goal.goal_type = "ee_pose"
        self.goal.weight_goal_0 = 1.0 * self._gazebo_factor
        self.goal.weight_goal_1 = 5.0 * self._gazebo_factor
        self.goal.tolerance_goal_0 = 0.02
        self.goal.tolerance_goal_1 = 0.02
        for _ in range(10):
            self._goal_publisher.publish(self.goal)

    # returns points on circumference of a circle, i.e. center of each sphere
    def ring_spheres(self):
        self.obs = FabricsObstacleArray()
        if self._randomize:
            ring_orientation = generate_random_orientation(self._goal_orientation, rotation=0.1, tilting=0.1)
        else:
            ring_orientation = self._static_ring_orientation
        rotation_matrix_ring = quaternionic.array(ring_orientation).to_rotation_matrix
        whole_position = np.array(
                [
                    self.goal.goal_pose.pose.position.x,
                    self.goal.goal_pose.pose.position.y,
                    self.goal.goal_pose.pose.position.z
                ]
            )
        radius_ring = 0.27
        for i in range(self._obstacle_resolution + 1):
            angle = i/self._obstacle_resolution * 2.*np.pi
            origin_position = [
                radius_ring * np.cos(angle),
                radius_ring * np.sin(angle),
                0.05,
            ]
            position = np.dot(np.transpose(rotation_matrix_ring), origin_position) + whole_position
            obstacle = FabricsObstacle()
            obstacle.header.frame_id = "panda_link0"
            obstacle.radius = 0.08
            obstacle.position = Point(x=position[0], y=position[1], z=position[2])
            self.obs.obstacles.append(obstacle)
        self._obs_publisher.publish(self.obs)


    def evaluate_distance_to_goal(self, goal_position: np.ndarray):
        return np.linalg.norm(goal_position - self.get_current_pose(rospy.get_param("/end_effector_link"))) / self._initial_distance_to_goal

    def objective(self, trial=None):
        self.return_home()
        if self.stopped():
            return {"path_length": 1.0, "time_to_goal": 1.0, "obstacles": 1.0}
        if trial:
            self.sample_fabrics_params(trial)
        else:
            self.select_best_params()
        self._manually_ended = False
        self.publish_goal()
        self.ring_spheres()
        self.create_collision_metric(self.obs)
        # Initialize costs
        goal_position = np.array([self.goal.goal_pose.pose.position.x, self.goal.goal_pose.pose.position.y, self.goal.goal_pose.pose.position.z])
        self._initial_distance_to_goal = np.linalg.norm(self.get_current_pose(rospy.get_param("/end_effector_link")) - goal_position)
        initial_distance_to_obstacles = self.evaluate_distance_to_closest_obstacle(self.obs, self._joint_positions)
        distances_to_goal = []
        distances_to_closest_obstacle = []
        path_length = 0.0
        start = rospy.Time.now().to_sec()
        rospy.loginfo(f"Starting trial at {start}")
        x_old = self._joint_positions
        while (rospy.Time.now().to_sec() - start) < self._maximum_seconds:
            self._goal_publisher.publish(self.goal)
            path_length += np.linalg.norm(self._joint_positions - x_old)
            x_old = self._joint_positions
            distances_to_goal.append(self.evaluate_distance_to_goal(goal_position))
            distances_to_closest_obstacle.append(self.evaluate_distance_to_closest_obstacle(self.obs, self._joint_positions))
            if self._manually_ended:
                return {"path_length": 1.0, "time_to_goal": 1.0, "obstacles": 1.0}
            self._rate.sleep()
        costs = {
            "path_length": path_length/10,
            "time_to_goal": np.mean(np.array(distances_to_goal)),
            "obstacles": 1 - np.min(distances_to_closest_obstacle) / initial_distance_to_obstacles
        }
        return costs

if __name__ == "__main__":
    optuna_node = PoseOptunaNode()
    try:
        optuna_node.run()
    except rospy.ROSInterruptException:
        pass
