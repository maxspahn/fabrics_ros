#!/usr/bin/env python3

# ros imports
import rospy
import tf
from fabrics_msgs.msg import FabricsGoal, FabricsObstacleArray, FabricsObstacle, FabricsState
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point

from pynput.keyboard import Listener,KeyCode
import joblib
import optuna
import quaternionic

from fabrics_bridge.rectangle_spheres import *
from fabrics_bridge.optuna_node import OptunaNode

def generate_random_orientation(w_amp, z_amp):
    quat_array =  np.array([-0.707 + np.random.random(1) * w_amp, 0, -0.707 + np.random.random(1) * z_amp, 0])
    return quat_array/np.linalg.norm(quat_array)


class PoseOptunaNode(OptunaNode):
    def __init__(self, study_file: str = None):
        super().__init__(study_file=study_file)
        self._obstacle_resolution = 10
        self.tf_listener = tf.TransformListener()

    def publish_goal(self, weight):
        self.goal = FabricsGoal()
        self.goal.goal_pose.pose.position.x = np.random.random(1) * 0.2 + 0.6
        self.goal.goal_pose.pose.position.y = np.random.random(1) * 0.8 - 0.4
        self.goal.goal_pose.pose.position.z = np.random.random(1) * 0.5 + 0.3
        goal_orientation = generate_random_orientation(0.3, 0.4)
        self.goal.goal_pose.pose.orientation.x = goal_orientation[0]
        self.goal.goal_pose.pose.orientation.y = goal_orientation[1]
        self.goal.goal_pose.pose.orientation.z = goal_orientation[2]
        self.goal.goal_pose.pose.orientation.w = goal_orientation[3]
        self.goal.goal_type = "ee_pose"
        self.goal.weight_goal_0 = weight
        self.goal.weight_goal_1 = weight * 2
        self.goal.tolerance_goal_0 = 0.02
        self.goal.tolerance_goal_1 = 0.02
        self._goal_reached = 0
        for _ in range(10):
            self._goal_publisher.publish(self.goal)

    def sample_fabrics_params(self, trial):
        weight = trial.suggest_float('w', 0.1, 2, log=False)
        return {'attractor_weight': weight}

    def get_current_pose(self):
        trans, _ = self.tf_listener.lookupTransform("panda_link0", "panda_vacuum", rospy.Time(0))
        return np.array(trans)

    # returns points on circumference of a circle, i.e. center of each sphere
    def ring_spheres(self):
        self.obs = FabricsObstacleArray()
        ring_orientation = generate_random_orientation(0.3, 0.3)
        rotation_matrix_ring = quaternionic.array(ring_orientation).to_rotation_matrix
        whole_position = np.array(
                [
                    self.goal.goal_pose.pose.position.x,
                    self.goal.goal_pose.pose.position.y,
                    self.goal.goal_pose.pose.position.z
                ]
            )[:,0]
        radius_ring = 0.31
        for i in range(self._obstacle_resolution + 1):
            angle = i/self._obstacle_resolution * 2.*np.pi
            origin_position = [
                radius_ring * np.cos(angle),
                radius_ring * np.sin(angle),
                0.0,
            ]
            position = np.dot(np.transpose(rotation_matrix_ring), origin_position) + whole_position
            obstacle = FabricsObstacle()
            obstacle.header.frame_id = "panda_link0"
            obstacle.radius = 0.1
            obstacle.position = Point(x=position[0], y=position[1], z=position[2])
            self.obs.obstacles.append(obstacle)
        self._obs_publisher.publish(self.obs)


    def objective(self, trial):
        self.return_home()
        params = self.sample_fabrics_params(trial)
        weight = params['attractor_weight']
        self._goal_reached = 0
        self._manually_ended = False
        self.publish_goal(weight)
        self.ring_spheres()
        # Initialize costs
        goal_position = np.array([self.goal.goal_pose.pose.position.x, self.goal.goal_pose.pose.position.y, self.goal.goal_pose.pose.position.z])
        initial_distance_to_goal = np.linalg.norm(self.get_current_pose() - goal_position)
        path_length = 0.0
        distance_to_goal = 0.0
        for number_steps in range(self._maximum_steps):
            if number_steps % 10000 == 0:
                rospy.loginfo(f"Ran {number_steps} steps")
            self._rate.sleep()
            distance_to_goal += np.linalg.norm(self.get_current_pose() - goal_position)/initial_distance_to_goal
            path_length += np.linalg.norm(self._joint_positions - self._old_joint_positions)
            self._old_joint_positions = self._joint_positions
            if self._goal_reached > 100:
                break
            if self._manually_ended:
                return 100
        costs = {
            "path_length": path_length/initial_distance_to_goal,
            "time_to_goal": distance_to_goal/number_steps,
        }
        return self.total_costs(costs)

if __name__ == "__main__":
    optuna_node = PoseOptunaNode('pose_tuned.pkl')
    try:
        optuna_node.run()
    except rospy.ROSInterruptException:
        pass
