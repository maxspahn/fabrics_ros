#!/usr/bin/env python3
# general python imports
import numpy as np
import math
from scipy.spatial.transform import Rotation

# ros imports
import rospy
from geometry_msgs.msg import PoseStamped
from fabrics_msgs.msg import FabricGoal, FabricGoalArray, FabricsObstacle, FabricsObstacleArray

from visualization_msgs.msg import Marker, MarkerArray


class ClientNode(object):
    def __init__(self):
        rospy.init_node('client_node')
        self._rate = rospy.Rate(10)
        # if param num_obs is not set, default number of obstacles is 2
        self._num_obs = 2 if not rospy.has_param("num_obs") else rospy.get_param("num_obs")
        self.init_publishers()
        # ring of spheres setting
        # radius of shelf (suppose it's a circular shelf)
        self._radius_shelf = 0.3
        # number of spheres to compose a ring (depending on the param num_obs)
        self._num_sphere = self._num_obs
        self._sphere_resolution = 0.1

        # obstacle randomization setting
        self._is_randomized_obs = False
        self._sphere_r_low = 0.1
        self._sphere_r_high = 0.5
        # put obstacles to ultra far
        self._obs_pos_low = 10
        self._obs_pos_high = 20
        if self._is_randomized_obs:
            self._randomized_radius_list = np.zeros([self._num_obs, 1], dtype = float)
            self._randomized_pose_list = np.zeros([self._num_obs, 3], dtype = float)
            self.generate_random_obs()

    def init_publishers(self):
        self._goals_publisher = rospy.Publisher(
            'planning_goal',
            PoseStamped, queue_size=10
        )
        self._obs_publisher = rospy.Publisher(
            'planning_obs',
            FabricsObstacleArray, queue_size=10
        )
        self._sphere_markers_publisher = rospy.Publisher(
            'planning_sphere/markers',
            MarkerArray, queue_size=10
        )

    # a function generates random obstacle with random radius and position (given a range
    # this function is only called once if self._is_randomized_obs is set True
    def generate_random_obs(self):
        for i in range(rospy.get_param("num_obs")):
            # assign a random value from [self._sphere_r_low, self._sphere_r_high), includes low but excludes high
            self._randomized_radius_list[i] = np.random.uniform(self._sphere_r_low, self._sphere_r_high)
            # assign a random value from [self._obs_pos_low, self._obs_pos_high) to obs pos_x/y/z
            self._randomized_pose_list[i] = np.random.uniform(self._obs_pos_low, self._obs_pos_high, 3)
        print(self._randomized_radius_list)
        print(self._randomized_pose_list)

    def init_sphere(self, point, radius):
        sphere = FabricsObstacle()
        sphere.radius = radius
        sphere.position = point
        return sphere

    def init_marker(self, a, r, g, b):
            goal_marker = Marker()
            goal_marker.header.frame_id = "panda_link0"
            goal_marker.type = goal_marker.SPHERE
            goal_marker.action = goal_marker.ADD
            goal_marker.color.a = a
            goal_marker.color.r = r
            goal_marker.color.g = g
            goal_marker.color.b = b
            return goal_marker

    # given a goal pose and n-th iteration
    # returns point on circumference of a circle, i.e. center of each sphere
    def generate_ring_spheres(self, pose, n):
        # retrieve pose of a goal
        pos_x = pose.position.x
        pos_y = pose.position.y
        pos_z = pose.position.z
        quat_x = pose.orientation.x
        quat_y = pose.orientation.y
        quat_z = pose.orientation.z
        quat_w = pose.orientation.w
        # get rotation matrix
        rot = Rotation.from_quat([quat_x, quat_y, quat_z, quat_w])
        rot_matrix = rot.as_matrix()
        '''
        Given a center point (pos_x, pos_y, poz_z) of a circle
        and an initial circle along y-z plane (when there is no rotation, the normal vector of a circle is along x axis) 
        An initial circle can be be represented as [0, radius*cos(theta),radius*sin(theta)] (polar coordinates)
        All points on a rotated circle can be obtained by using the rotation matrix
        rotated_circle = [center_x, center_y, center_z] + rot_matrix*initial_circle
        '''
        initial_circle = np.array([[self._radius_shelf * math.cos(n*2*math.pi/self._num_sphere)], [self._radius_shelf * math.sin(n*2*math.pi/self._num_sphere)],[0]]) 
        rotated_circle = np.array([[pos_x], [pos_y], [pos_z]]) + np.matmul(rot_matrix, initial_circle)
        return rotated_circle

    def publish_goals(self):
        goal_data = PoseStamped()
        goal_data.pose.position.x = rospy.get_param("goal_position_x")
        goal_data.pose.position.y = rospy.get_param("goal_position_y")
        goal_data.pose.position.z = rospy.get_param("goal_position_z")
        goal_data.pose.orientation.x = rospy.get_param("goal_orientation_x")
        goal_data.pose.orientation.y = rospy.get_param("goal_orientation_y")
        goal_data.pose.orientation.z = rospy.get_param("goal_orientation_z")
        goal_data.pose.orientation.w = rospy.get_param("goal_orientation_w")
        goal_data.header.frame_id = "panda_link0"

        self._goals_publisher.publish(goal_data)
        self._sphere_markers = MarkerArray()
        for i in range(self._num_sphere):
            # red sphere
            sphere_marker = self.init_marker(1.0, 0.0, 0.0, 1.0)
            sphere_marker.id = i
            x, y, z = self.generate_ring_spheres(goal_data.pose, i)
            sphere_marker.pose.position.x = float(x)
            sphere_marker.pose.position.y = float(y)
            sphere_marker.pose.position.z = float(z)
            sphere_marker.pose.orientation.w = 1.0
            sphere_marker.scale.x = self._sphere_resolution
            sphere_marker.scale.y = self._sphere_resolution
            sphere_marker.scale.z = self._sphere_resolution
            self._sphere_markers.markers.append(sphere_marker)
        # publish sphere markers
        self._sphere_markers_publisher.publish(self._sphere_markers)

    def publish_obs(self):
        obs = FabricsObstacleArray()
        obs.header.stamp = rospy.Time.now()
        obs.header.frame_id = "panda_link0"
        # if self._is_randomized_obs:
        #     for i in range(self._num_obs):
        #         obs.primitives.append(self.init_sphere_size(self._randomized_radius_list[i]))
        #         obs.primitive_poses.append(self.init_sphere_pose(*self._randomized_pose_list[i]))
        # # set obstacles depending on the ring of spheres or manually set obstacles
        # else:
        for marker in self._sphere_markers.markers:
                    obs.obstacles.append(self.init_sphere(marker.pose.position, self._sphere_resolution/2))
        self._obs_publisher.publish(obs)

    def run(self):
        while not rospy.is_shutdown():     
            use_it_marker = False if not rospy.has_param("use_it_marker") else rospy.get_param("use_it_marker")
            if not use_it_marker:
                self.publish_goals()
                self.publish_obs()
            self._rate.sleep()

if __name__ == "__main__":
    ClientNode = ClientNode()
    try:
        ClientNode.run()
    except rospy.ROSInterruptException:
        pass



