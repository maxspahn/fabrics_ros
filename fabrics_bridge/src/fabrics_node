#!/usr/bin/env python3
# general imports
import numpy as np
import time
import datetime

# fabrics imports
# from fabrics.planner.fabricPlanner import DefaultFabricPlanner
# TODO
# ask why DefaultFabricPlanner doesn't have setObstacles() and setGoal()
# difference??
from fabricPlanner import FabricPlanner


# ros imports
import rospy
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point

from fabrics_msgs.msg import FabricGoal
from fabrics_msgs.msg import FabricGoalArray

from ros_converter_node import ActionConverterNode
from experiment import Experiment


class FabricNode(object):
    def __init__(self):
        rospy.init_node('fabric_node')
        self._rate = rospy.Rate(500)

        # initial setup
        # wait for /planning_goals being published
        goals = rospy.wait_for_message("/planning_goals", FabricGoalArray)
        self.set_planner_file()
        self.set_goal_subscriber()
        self.set_variables()

        self.set_action_publisher()
        self.set_joint_state_subscriber()


    # this function wrap params from fabric.yaml into a dictionary as an input for FabricPlanner()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    def set_planner_file(self):
        self._planner_file = {}
        self._planner_file.update({"interval": rospy.get_param("interval")})
        self._planner_file.update({"type": rospy.get_param("type")})
        self._planner_file.update({"n": rospy.get_param("n")})
        self._planner_file.update({"m_base": rospy.get_param("m_base")})
        self._planner_file.update({"obst": rospy.get_param("obst")})
        self._planner_file.update({"selfCol": rospy.get_param("selfCol")})
        self._planner_file.update({"attractor": rospy.get_param("attractor")})
        self._planner_file.update({"limits": rospy.get_param("limits")})
        self._planner_file.update({"speed": rospy.get_param("speed")})
        self._planner_file.update({"damper": rospy.get_param("damper")})
        self._planner_file.update({"dynamic": rospy.get_param("dynamic")})

    # this function wrap params from exp.yaml into a dictionary as an input for Experiment()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    def set_exp_file(self):
        self._exp_file = {}
        self._exp_file.update({"T": rospy.get_param("T")})
        self._exp_file.update({"dynamic": rospy.get_param("dynamic")})
        self._exp_file.update({"dt": rospy.get_param("dt")})
        self._exp_file.update({"robot_type": rospy.get_param("robot_type")})
        self._exp_file.update({"n": rospy.get_param("n")})
        self._exp_file.update({"limits": rospy.get_param("limits")})
        self._exp_file.update({"r_body": rospy.get_param("r_body")})
        self._exp_file.update({"selfCollision": rospy.get_param("selfCollision")})
        self._exp_file.update({"obstacles": rospy.get_param("obstacles")})
        self._exp_file.update(self._goal_dic)
        self._experiment = Experiment(self._exp_file)

        # set goals and obstacles in the callback loop as they could be changing in run-time
        self.set_planner()
        self.RosConverter()
        self.run()

    def set_planner(self):
        self._planner = FabricPlanner(self._experiment, self._planner_file)
        self._planner.setJointLimits(self._experiment.limits())
        self._planner.setSelfCollisionAvoidance(self._experiment.rBody())
        self._planner.setObstacles(self._experiment.obstacles(), self._experiment.rBody())
        self._planner.setGoal(self._experiment.goal())
        self._planner.concretize()

    def set_variables(self):
        # plannar.param
        self._n =  rospy.get_param("n")
        self._dt = rospy.get_param("dt")
        self._T = 5000

    def set_goal_subscriber(self):
        self._goal = np.zeros(3)
        self._goal_subscriber = rospy.Subscriber(
            '/planning_goals',
            FabricGoalArray, self.goal_callback
        )

    def goal_callback(self, goals_data: FabricGoalArray):
        self._goal_dic = {}
        self._goal_id = 0
        for goal in goals_data.goals:
            self._goal_id += 1
            self._goal_dic["goal"] = {
            "subgoal"+ str(self._goal_id):
            {"prime": goal.prime, "m": goal.m, "w": goal.w, "indices": list(goal.indices), "parent_link": goal.parent_link,
            "child_link": goal.child_link, "desired_position": [goal.position.x, goal.position.y, goal.position.z],
            "type": goal.type, "epsilon": goal.epsilon}
            }
        self.set_exp_file()

    def set_joint_state_subscriber(self):
        self._joint_positions = np.zeros(self.n)
        self._joint_velocities = np.zeros(self.n)
        self._joint_state_subscriber = rospy.Subscriber(
            '/joint_states',
            JointState, self.joint_states_callback
        )

    def joint_states_callback(self, joint_states_data: JointState):
        self._joint_positions = np.array(joint_states_data.position)
        self._joint_velocities = np.array(joint_states_data.velocity)

    def set_action_publisher(self):
        self._action_publisher = rospy.Publisher(
            '/joint_desired_accelerations', 
            Float64MultiArray, queue_size=10
        )
        self._action_message = Float64MultiArray(data=np.zeros(self.n))

    def compute_action(self):
        # here the observation is not filtered, it's directly from /joint_states
        return self._planner.computeAction(self._joint_positions[3:10], self._joint_velocities[3:10])

    def publish_action(self, action: np.ndarray):
        self._action_message.data = action
        self._action_publisher.publish(self._action_message)

    def act(self):
        action = self.compute_action()
        self.publish_action(action)
        return action

    def RosConverter(self):
        rate_int = int(1/self._dt)
        self._rosConverter = ActionConverterNode(self._dt, rate_int, self._experiment.robotType())

    def run(self):
        print("start run")
        start=time.perf_counter()
        print(f"Planner composed in {np.round(time.perf_counter()-start, decimals=2)} sec")
        timeStamp = "{:%Y%m%d_%H%M%S}".format(datetime.datetime.now())
        t = 0.0
        t0 = 0.0
        for i in range(self._T):

            if i % 1000 == 0:
                print("Timestep : %d" %i)

            action = self.act()
            ob, t_new = self.applyAction(action, t)
            t = t_new - t0


    def applyAction(self, action, t_exp):
        ob, t = self._rosConverter.publishAction(action)
        self._rosConverter.setGoal(self._experiment.primeGoal(), t=t_exp)
        for i, obst in enumerate(self._experiment.obstacles()):
            self._rosConverter.setObstacle(obst, i, t=t_exp)
        return ob, t


    @property
    def n(self):
        return self._n

    # def run(self):
    #     while not rospy.is_shutdown():
    #         self.act()
    #         self._rate.sleep()


if __name__ == "__main__":
    myFabricNode = FabricNode()
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
