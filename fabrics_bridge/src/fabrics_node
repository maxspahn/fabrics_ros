#!/usr/bin/env python3
# general imports
import numpy as np
import time
import datetime

# fabrics imports
# from fabrics.planner.fabricPlanner import DefaultFabricPlanner
# TODO
# ask why DefaultFabricPlanner doesn't have setObstacles() and setGoal()
# difference??
# from fabricPlanner import FabricPlanner


# ros imports
import rospy
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from visualization_msgs.msg import Marker, MarkerArray


from fabrics_msgs.msg import FabricGoal
from fabrics_msgs.msg import FabricGoalArray

from ros_converter_node import ActionConverterNode
from experiment import Experiment

from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from forwardkinematics.urdfFks.pandaFk import PandaFk

def set_planner():
    degrees_of_freedom = 7
    damper = {
            "alpha_b": 0.5,
            "alpha_eta": 0.5,
            "alpha_shift": 0.5,
            "beta_distant": 0.01,
            "beta_close": 20,
            "radius_shift": 0.1
    }
    attractor_potential = "10 * ca.norm_2(x)**2"
    planner = ParameterizedFabricPlanner(
            degrees_of_freedom,
            damper=damper
    )
    q = planner.variables.position_variable()
    panda_fk = PandaFk()
    forward_kinematics = []
    for i in range(1, degrees_of_freedom):
        forward_kinematics.append(panda_fk.fk(q, i, positionOnly=True))
    forward_kinematics_end_effector = panda_fk.fk(
        q, 7, positionOnly=True
    )
    forward_kinematics.append(forward_kinematics_end_effector)
    planner.set_components(
        forward_kinematics,
        forward_kinematics_end_effector,
        number_obstacles=0,
        goal=True,
    )
    planner.concretize()
    return planner


class FabricNode(object):
    def __init__(self):
        rospy.init_node('fabric_node')
        self._planner = set_planner()
        self._rate = rospy.Rate(500)

        # initial setup
        # wait for /planning_goals being published, otherwise don't do anything
        goals = rospy.wait_for_message("/planning_goals", FabricGoalArray)
        #self.set_planner_file()
        self.set_goal_subscriber()
        self.set_variables()

        self.set_action_publisher()
        self.set_goals_markers_publisher()
        self.set_joint_state_subscriber()


    # this function wrap params from fabric.yaml into a dictionary as an input for FabricPlanner()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    def set_planner_file(self):
        self._planner_file = {}
        self._planner_file.update({"interval": rospy.get_param("interval")})
        self._planner_file.update({"type": rospy.get_param("type")})
        self._planner_file.update({"n": rospy.get_param("n")})
        self._planner_file.update({"m_base": rospy.get_param("m_base")})
        self._planner_file.update({"obst": rospy.get_param("obst")})
        self._planner_file.update({"selfCol": rospy.get_param("selfCol")})
        self._planner_file.update({"attractor": rospy.get_param("attractor")})
        self._planner_file.update({"limits": rospy.get_param("limits")})
        self._planner_file.update({"speed": rospy.get_param("speed")})
        self._planner_file.update({"damper": rospy.get_param("damper")})
        self._planner_file.update({"dynamic": rospy.get_param("dynamic")})

    # this function wrap params from exp.yaml into a dictionary as an input for Experiment()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    # def set_exp_file(self):
    #   print("DEPRECATED")
    #     self._exp_file = {}
    #     self._exp_file.update({"T": rospy.get_param("T")})
    #     self._exp_file.update({"dynamic": rospy.get_param("dynamic")})
    #     self._exp_file.update({"dt": rospy.get_param("dt")})
    #     self._exp_file.update({"robot_type": rospy.get_param("robot_type")})
    #     self._exp_file.update({"n": rospy.get_param("n")})
    #     self._exp_file.update({"limits": rospy.get_param("limits")})
    #     self._exp_file.update({"r_body": rospy.get_param("r_body")})
    #     self._exp_file.update({"selfCollision": rospy.get_param("selfCollision")})
    #     self._exp_file.update({"obstacles": rospy.get_param("obstacles")})
    #     self._exp_file.update(self._goal_dic)
    #     self._experiment = Experiment(self._exp_file)

        # set goals and obstacles in the callback loop as they could be changing in run-time
        # self.set_planner()
        # self.RosConverter()
        # self.run()

    # def set_planner(self):
        # print("DEPRECATED")
        #self._planner = FabricPlanner(self._experiment, self._planner_file)
        #self._planner.setJointLimits(self._experiment.limits())
        #self._planner.setSelfCollisionAvoidance(self._experiment.rBody())
        #self._planner.setObstacles(self._experiment.obstacles(), self._experiment.rBody())
        #self._planner.setGoal(self._experiment.goal())
        #self._planner.concretize()

    def set_variables(self):
        # plannar.param
        self._n =  rospy.get_param("n")
        self._dt = rospy.get_param("dt")
        self._T = 5000

    def set_goals_markers_publisher(self):
        self._goals_markers_publisher = rospy.Publisher(
            '/planning_goals/markers',
            MarkerArray, queue_size=10
        )
    def init_goal_marker(self):
            goal_marker = Marker()
            goal_marker.header.frame_id = "panda_link0"
            goal_marker.type = goal_marker.SPHERE
            goal_marker.action = goal_marker.ADD
            goal_marker.color.a = 1.0
            goal_marker.color.r = 0.0
            goal_marker.color.g = 1.0
            goal_marker.color.b = 0.0
            return goal_marker


    def set_goal_subscriber(self):
        self._goal = np.array([0.8, 0.0, 0.6])
        self._goal_subscriber = rospy.Subscriber(
            '/planning_goals',
            FabricGoalArray, self.goal_callback
        )

    def goal_callback(self, goals_data: FabricGoalArray):
        self._goal_dic = {}
        self._goal_id = 0
        self._goals_markers = MarkerArray()

        for goal in goals_data.goals:
            self._goal_id += 1
            self._goal_dic["goal"] = {
            "subgoal"+ str(self._goal_id):
            {"prime": goal.prime, "m": goal.m, "w": goal.w, "indices": list(goal.indices), "parent_link": goal.parent_link,
            "child_link": goal.child_link, "desired_position": [goal.position.x, goal.position.y, goal.position.z],
            "type": goal.type, "epsilon": goal.epsilon}
            }
            self._goal = np.array([goal.position.x, goal.position.y, goal.position.z])
            rospy.loginfo("Going to goal (%f, %f, %f)", self._goal[0], self._goal[1], self._goal[2])
            # section for filling in goal marker
            goal_marker = self.init_goal_marker()
            goal_marker.id = self._goal_id
            goal_marker.pose.position.x = goal.position.x
            goal_marker.pose.position.y = goal.position.y
            goal_marker.pose.position.z = goal.position.z
            goal_marker.pose.orientation.w = 1.0
            goal_marker.scale.x = goal.epsilon
            goal_marker.scale.y = goal.epsilon
            goal_marker.scale.z = goal.epsilon
            self._goals_markers.markers.append(goal_marker)
        self._goals_markers_publisher.publish(self._goals_markers)

        self.act()

    def set_joint_state_subscriber(self):
        self._joint_positions = np.zeros(3 + self.n)
        self._joint_velocities = np.zeros(3 + self.n)
        self._joint_state_subscriber = rospy.Subscriber(
            '/joint_states',
            JointState, self.joint_states_callback
        )

    def joint_states_callback(self, joint_states_data: JointState):
        self._joint_positions = np.array(joint_states_data.position)
        self._joint_velocities = np.array(joint_states_data.velocity)

    def set_action_publisher(self):
        self._action_publisher = rospy.Publisher(
            '/joint_acc_des', 
            Float64MultiArray, queue_size=10
        )
        self._action_message = Float64MultiArray(data=np.zeros(9))


    def compute_action(self):
        # here the observation is not filtered, it's directly from /joint_states
        # rospy.loginfo("Going to goal (%f, %f, %f)", self._goal[0], self._goal[1], self._goal[2])
        return self._planner.compute_action(
            q=self._joint_positions[3:10],
            qdot=self._joint_velocities[3:10],
            x_goal=self._goal,
        )

    def publish_action(self, action: np.ndarray):
        self._action_message.data[2:] = action
        self._action_publisher.publish(self._action_message)

    def act(self):
        action = self.compute_action()
        self.publish_action(action)
        return action

    # def RosConverter(self):
    #     rate_int = int(1/self._dt)
    #     self._rosConverter = ActionConverterNode(self._dt, rate_int, self._experiment.robotType())

    # def applyAction(self, action, t_exp):
    #     ob, t = self._rosConverter.publishAction(action)
    #     self._rosConverter.setGoal(self._experiment.primeGoal(), t=t_exp)
    #     for i, obst in enumerate(self._experiment.obstacles()):
    #         self._rosConverter.setObstacle(obst, i, t=t_exp)
    #     return ob, t


    @property
    def n(self):
        return self._n

    # def run(self):
        # while not rospy.is_shutdown():
            # self.act()
            # self._rate.sleep()


if __name__ == "__main__":
    my_fabric_node = FabricNode()
    try:
        # my_fabric_node.run()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
