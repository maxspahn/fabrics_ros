#!/usr/bin/env python3
# general imports
import numpy as np
import time
import datetime

# ros imports
import rospy
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point
from visualization_msgs.msg import Marker, MarkerArray
# message types for storing obstacle info
from moveit_msgs.msg import CollisionObject

from fabrics_msgs.msg import FabricGoal
from fabrics_msgs.msg import FabricGoalArray

from ros_converter_node import ActionConverterNode
from MotionPlanningGoal.goalComposition import GoalComposition

from fabrics.planner.parameterized_planner import ParameterizedFabricPlanner
from forwardkinematics.urdfFks.pandaFk import PandaFk

from MotionPlanningEnv.sphereObstacle import SphereObstacle
from scipy.spatial.transform import Rotation



class FabricNode(object):
    def __init__(self, home_position=np.array([0.5, 0, 0.5])):
        # initial setups
        rospy.init_node('fabric_node')
        self._rate = rospy.Rate(500)
        # if param num_obs is not set, default number of obstacles is 2
        self._num_obs = 2 if not rospy.has_param("num_obs") else rospy.get_param("num_obs")
        self._goal = np.array([])
        self._goal_1_position = np.zeros(2)
        self._home_position = home_position
        self._obs_pose_list = np.zeros([self._num_obs, 3], dtype = float)
        self._obs_radius_list = np.zeros([self._num_obs, 1], dtype = float)
        self.set_goal_subscriber()
        self.set_obs_subscriber()
        self.set_variables()

        self.set_action_publisher()
        self.set_goals_markers_publisher()
        self.set_obs_markers_publisher()
        self.set_joint_state_subscriber()
        self._planner = self.set_planner()

    def set_planner(self):
        degrees_of_freedom = 7
        robot_type = 'panda'
        damper = {
                "alpha_b": 0.5,
                "alpha_eta": 0.5,
                "alpha_shift": 0.5,
                "beta_distant": 0.01,
                "beta_close": 10,
                "radius_shift": 0.1
        }
        # beta_close is for: when you close to a close, how much damping do you want
        # change the 100 to higher or lower
        # the higher it is, the more potential it is hence faster

        attractor_potential = "100 * ca.norm_2(x)**2"
        planner = ParameterizedFabricPlanner(degrees_of_freedom, robot_type)
        # Definition of the obstacle.
        static_obst_dict = {
            "dim": 3,
            "type": "sphere",
            "geometry": {"position": [0.5, -0.3, 0.3], "radius": 0.1},
        }
        self.obst1 = SphereObstacle(name="staticObst", contentDict=static_obst_dict)
        static_obst_dict = {
            "dim": 3,
            "type": "sphere",
            "geometry": {"position": [-0.7, 0.0, 0.5], "radius": 0.1},
        }
        self.obst2 = SphereObstacle(name="staticObst", contentDict=static_obst_dict)
        # weight of subgoal0 is the attractor_potential
        goal_dict = {
        "subgoal0": {
            "m": 3,
            "w": 200.0,
            "prime": True,
            "indices": [0, 1, 2],
            "parent_link": 0,
            "child_link": 7,
            "desired_position": [0.1, -0.6, 0.4],
            "epsilon": 0.01,
            "type": "staticSubGoal",
        },
        "subgoal1": {
            "m": 2,
            "w": 20.0,
            "prime": False,
            "indices": [0, 1],
            "parent_link": 6,
            "child_link": 7,
            "angle": [0.0, 0.4, 0.8, 0.3],
            "desired_position": [0.0, 0.0],
            "epsilon": 0.05,
            "type": "staticSubGoal",
        }
        }
        self.goal = GoalComposition(name="goal", contentDict=goal_dict)

        planner = ParameterizedFabricPlanner(degrees_of_freedom, robot_type)
        q = planner.variables.position_variable()
        panda_fk = PandaFk()
        forward_kinematics = []
        for i in range(1, degrees_of_freedom+1):
            forward_kinematics.append(panda_fk.fk(q, i, positionOnly=True))
        # The planner hides all the logic behind the function set_components.
        planner.set_components(
            forward_kinematics,
            self.goal,
            number_obstacles=self._num_obs,
        )
        planner.concretize()
    
        return planner



    def set_variables(self):
        # plannar.param
        self._n =  rospy.get_param("n")
        self._dt = rospy.get_param("dt")
        self._T = 5000

    def set_goals_markers_publisher(self):
        self._goals_markers_publisher = rospy.Publisher(
            '/planning_goals/markers',
            MarkerArray, queue_size=10
        )

    def set_obs_markers_publisher(self):
        self._obs_markers_publisher = rospy.Publisher(
            '/planning_obs/markers',
            MarkerArray, queue_size=10
    )

    def init_marker(self, a, r, g, b, type):
            goal_marker = Marker()
            goal_marker.header.frame_id = "panda_link0"
            goal_marker.type = type
            goal_marker.action = goal_marker.ADD
            goal_marker.color.a = a
            goal_marker.color.r = r
            goal_marker.color.g = g
            goal_marker.color.b = b
            return goal_marker

    def set_goal_subscriber(self):
        self._goal_subscriber = rospy.Subscriber(
            '/planning_goals',
            FabricGoalArray, self.goal_callback
        )

    def goal_callback(self, goals_data: FabricGoalArray):
        # self._goal_dic = {}
        self._goal_id = 0
        self._goals_markers = MarkerArray()

        for goal in goals_data.goals:
            self._goal_id += 1
            # self._goal_dic["goal"] = {
            # "subgoal"+ str(self._goal_id):
            # {"prime": goal.prime, "m": goal.m, "w": goal.w, "indices": list(goal.indices), "parent_link": goal.parent_link,
            # "child_link": goal.child_link, "desired_position": [goal.position.x, goal.position.y, goal.position.z],
            # "type": goal.type, "epsilon": goal.epsilon}
            # }
            self._goal_position = np.array([goal.pose.position.x, goal.pose.position.y, goal.pose.position.z])
            self._goal_orientation = [goal.pose.orientation.x, goal.pose.orientation.y, goal.pose.orientation.z, goal.pose.orientation.w]

            # section for filling in goal marker
            # green markers for goals
            # the parameter are color (a,r,g,b) and marker type (ARROW=0)
            goal_marker = self.init_marker(1.0, 0.0, 1.0, 0.0, 0)
            goal_marker.id = self._goal_id
            goal_marker.pose.position.x = goal.pose.position.x
            goal_marker.pose.position.y = goal.pose.position.y
            goal_marker.pose.position.z = goal.pose.position.z
            goal_marker.pose.orientation.x = goal.pose.orientation.x
            goal_marker.pose.orientation.y = goal.pose.orientation.y
            goal_marker.pose.orientation.z = goal.pose.orientation.z
            goal_marker.pose.orientation.w = goal.pose.orientation.w
            goal_marker.scale.x = goal.epsilon
            goal_marker.scale.y = goal.epsilon
            goal_marker.scale.z = goal.epsilon
            self._goals_markers.markers.append(goal_marker)
        # publish goal markers
        self._goals_markers_publisher.publish(self._goals_markers)

    def set_obs_subscriber(self):
        self._obs_subscriber = rospy.Subscriber(
            '/planning_obs',
            CollisionObject, self.obs_callback
        )

    def obs_callback(self, obs: CollisionObject):
        self._obs_markers = MarkerArray()
        for i in range(len(obs.primitives)):
            self._obs_radius_list[i] = (obs.primitives[i].dimensions[0])
            self._obs_pose_list[i] = np.array([obs.primitive_poses[i].position.x, obs.primitive_poses[i].position.y, obs.primitive_poses[i].position.z])
            # section for filling in obstacle marker
            # pass red color and sphere type (SPHERE=2) to initiate marker for obstacle
            obs_marker = self.init_marker(1.0, 1.0, 0.0, 0.0, 2)
            obs_marker.id = i
            obs_marker.pose.position.x = obs.primitive_poses[i].position.x
            obs_marker.pose.position.y = obs.primitive_poses[i].position.y
            obs_marker.pose.position.z = obs.primitive_poses[i].position.z
            obs_marker.pose.orientation.w = 1.0
            # primitives[i].dimensions[0] is radius of a sphere
            # and Marker.scale of a sphere is diameter in x/y/z direction
            # so multiply by 2
            obs_marker.scale.x = 2*obs.primitives[i].dimensions[0]
            obs_marker.scale.y = 2*obs.primitives[i].dimensions[0]
            obs_marker.scale.z = 2*obs.primitives[i].dimensions[0]
            self._obs_markers.markers.append(obs_marker)
        # publish obs markers
        self._obs_markers_publisher.publish(self._obs_markers)

    # here the observation is not filtered, it's directly from /joint_states
    # if it's /joint_states_filtered it goes crazy
    # TODO is /joint_states_filtered or /joint_states
    def set_joint_state_subscriber(self):
        self._joint_positions = np.zeros(3 + self.n)
        self._joint_velocities = np.zeros(3 + self.n)
        self._joint_state_subscriber = rospy.Subscriber(
            '/joint_states',
            JointState, self.joint_states_callback,
            tcp_nodelay=True
        )

    def joint_states_callback(self, joint_states_data: JointState):
        self._joint_positions = np.array(joint_states_data.position)
        self._joint_velocities = np.array(joint_states_data.velocity)

    def set_action_publisher(self):
        self._action_publisher = rospy.Publisher(
            '/joint_acc_des', 
            Float64MultiArray, queue_size=10
        )
        self._action_message = Float64MultiArray(data=np.zeros(9))


    def compute_action(self):
        sub_goal_0_position = np.array(self.goal.subGoals()[0].position())
        sub_goal_0_weight= np.array(self.goal.subGoals()[0].weight())
        sub_goal_1_position = np.array(self.goal.subGoals()[1].position())
        sub_goal_1_weight= np.array(self.goal.subGoals()[1].weight())
        obst1_position = np.array(self.obst1.position())
        obst2_position = np.array(self.obst2.position())
        
        sub_goal_0_angles = np.identity(3)
        # sub_goal_1_angles = np.array([[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]])
        # get the goal orientation and convert to rotation matrix
        sub_goal_before_rot = Rotation.from_quat(self._goal_orientation).as_euler('xyz')
        # rotation correction
        sub_goal_after_rot = sub_goal_before_rot + [0, -1.57 , 0]
        sub_goal_1_angles = Rotation.from_euler('xyz',sub_goal_after_rot).as_matrix()
        
        return self._planner.compute_action(
            q=self._joint_positions[3:10],
            qdot=self._joint_velocities[3:10],
            x_goal_0=self._goal_position,
            angle_goal_1=sub_goal_1_angles,
            weight_goal_0=sub_goal_0_weight,
            x_goal_1=self._goal_1_position,
            weight_goal_1=sub_goal_1_weight,
            x_obst = self._obs_pose_list,
            radius_obst = self._obs_radius_list,
            radius_body=np.array([0.02]),
        )

#  action = planner.compute_action(
#             q=ob["x"],
#             qdot=ob["xdot"],
#             x_goal_0=sub_goal_0_position,
#             angle_goal_1=sub_goal_1_angles,
#             weight_goal_0=sub_goal_0_weight,
#             x_goal_1=sub_goal_1_position,
#             weight_goal_1=sub_goal_1_weight,
#             x_obst_0=obst2_position,
#             x_obst_1=obst1_position,
#             radius_obst_0=np.array([obst1.radius()]),
#             radius_obst_1=np.array([obst2.radius()]),
#             radius_body=np.array([0.02]),
#         )

        print("finished computing")
    def publish_action(self, action: np.ndarray):
        self._action_message.data[2:] = action
        self._action_publisher.publish(self._action_message)

    def act(self):
        action = self.compute_action()
        self.publish_action(action)
        return action

    # legacy section
    # this function wrap params from fabric.yaml into a dictionary as an input for FabricPlanner()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    # def set_planner_file(self):
    #     self._planner_file = {}
    #     self._planner_file.update({"interval": rospy.get_param("interval")})
    #     self._planner_file.update({"type": rospy.get_param("type")})
    #     self._planner_file.update({"n": rospy.get_param("n")})
    #     self._planner_file.update({"m_base": rospy.get_param("m_base")})
    #     self._planner_file.update({"obst": rospy.get_param("obst")})
    #     self._planner_file.update({"selfCol": rospy.get_param("selfCol")})
    #     self._planner_file.update({"attractor": rospy.get_param("attractor")})
    #     self._planner_file.update({"limits": rospy.get_param("limits")})
    #     self._planner_file.update({"speed": rospy.get_param("speed")})
    #     self._planner_file.update({"damper": rospy.get_param("damper")})
    #     self._planner_file.update({"dynamic": rospy.get_param("dynamic")})

    # this function wrap params from exp.yaml into a dictionary as an input for Experiment()
    # ideally the dictionary shouldn't be necessary, but this is a temporary solution to make
    # sure every modules work correctly
    # def set_exp_file(self):
    #   print("DEPRECATED")
    #     self._exp_file = {}
    #     self._exp_file.update({"T": rospy.get_param("T")})
    #     self._exp_file.update({"dynamic": rospy.get_param("dynamic")})
    #     self._exp_file.update({"dt": rospy.get_param("dt")})
    #     self._exp_file.update({"robot_type": rospy.get_param("robot_type")})
    #     self._exp_file.update({"n": rospy.get_param("n")})
    #     self._exp_file.update({"limits": rospy.get_param("limits")})
    #     self._exp_file.update({"r_body": rospy.get_param("r_body")})
    #     self._exp_file.update({"selfCollision": rospy.get_param("selfCollision")})
    #     self._exp_file.update({"obstacles": rospy.get_param("obstacles")})
    #     self._exp_file.update(self._goal_dic)
    #     self._experiment = Experiment(self._exp_file)

        # set goals and obstacles in the callback loop as they could be changing in run-time
        # self.set_planner()
        # self.RosConverter()
        # self.run()

    # def set_planner(self):
        # print("DEPRECATED")
        #self._planner = FabricPlanner(self._experiment, self._planner_file)
        #self._planner.setJointLimits(self._experiment.limits())
        #self._planner.setSelfCollisionAvoidance(self._experiment.rBody())
        #self._planner.setObstacles(self._experiment.obstacles(), self._experiment.rBody())
        #self._planner.setGoal(self._experiment.goal())
        #self._planner.concretize()

    @property
    def n(self):
        return self._n

    def run(self):
        while not rospy.is_shutdown():
            # check if there is connection between self._goal_subscriber
            # i.e. check if there is goal(s) being published
            # if goal_connection == 0 which means there is no connection
            # then go to the home position
            goal_connection = self._goal_subscriber.get_num_connections()
            if goal_connection == 0:
                # go to home position if there is no /planning_goals received
                self._goal = self._home_position
                rospy.loginfo("Going home (%f, %f, %f)", self._goal[0], self._goal[1], self._goal[2])
                self.act()
            else:
                self.act()
            self._rate.sleep()

if __name__ == "__main__":
    my_fabric_node = FabricNode()
    try:
        my_fabric_node.run()
    except rospy.ROSInterruptException:
        pass
